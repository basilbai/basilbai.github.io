<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>React-原理揭秘实践(上) - Basil</title>

  
    <meta name="description" content="用实践来揭开 React 的神秘面纱~">
<meta property="og:type" content="article">
<meta property="og:title" content="React-原理揭秘实践(上)">
<meta property="og:url" content="https://basilbai.github.io/2018/08/12/React-%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98%E5%AE%9E%E8%B7%B5-%E4%B8%8A/index.html">
<meta property="og:site_name" content="Basil">
<meta property="og:description" content="用实践来揭开 React 的神秘面纱~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd034c84e81ad?w=357&h=588&f=jpeg&s=23458">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd046b8a7cfcd?w=1068&h=622&f=jpeg&s=37416">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd04a1c761185?w=1450&h=1042&f=jpeg&s=46707">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd04d40973064?w=750&h=389&f=gif&s=941267">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd0505762e643?w=585&h=350&f=gif&s=724488">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd0542e834ceb?w=750&h=410&f=gif&s=692139">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd057514a585e?w=750&h=420&f=gif&s=814595">
<meta property="article:published_time" content="2018-08-12T11:28:26.000Z">
<meta property="article:modified_time" content="2022-06-18T07:11:15.766Z">
<meta property="article:author" content="Basil">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/3/9/170bd034c84e81ad?w=357&h=588&f=jpeg&s=23458">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">Basil</div><div class="sub cap">热爱技术记录分享</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/notes/">笔记</a><a class="nav-item" href="/more/">更多</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%99-%E7%A9%BF%E8%B6%8A%E4%B9%8B%E9%97%A8-JSX"><span class="toc-text">第一站: 穿越之门 - JSX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#babel-plugin-transform-jsx"><span class="toc-text">babel-plugin-transform-jsx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%99-%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E-Virtual-DOM"><span class="toc-text">第二站: 天空之城 - Virtual DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%99-%E8%BD%AC%E6%8D%A2%E4%B9%8B%E6%A1%A5-createElement"><span class="toc-text">第三站: 转换之桥 - createElement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WebGL-API"><span class="toc-text">WebGL API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%99-%E5%88%9B%E9%80%A0%E4%B9%8B%E6%9F%B1-Render"><span class="toc-text">第四站: 创造之柱 - Render</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%99-%E6%97%B6%E7%A9%BA%E4%B9%8B%E5%8C%99-Diff"><span class="toc-text">第五站: 时空之匙 - Diff</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E5%B1%82%E6%AF%94%E5%AF%B9%E7%AD%96%E7%95%A5"><span class="toc-text">1. 同层比对策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AD%96%E7%95%A5"><span class="toc-text">2. 唯一标识策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F%E7%AD%96%E7%95%A5"><span class="toc-text">3. 组件模式策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diff-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Diff 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BD%93%E6%96%B0%E6%97%A7%E8%8A%82%E7%82%B9%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%9B%BF%E6%8D%A2-replaceVNode"><span class="toc-text">1. 当新旧节点不同时，直接替换 (replaceVNode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BD%93%E6%96%B0%E6%97%A7%E8%8A%82%E7%82%B9%E4%B8%BA%E5%90%8C%E4%B8%80%E8%8A%82%E7%82%B9%E6%97%B6%EF%BC%8C%E5%BC%80%E5%A7%8B%E6%AD%A3%E5%BC%8F%E7%9A%84%E6%AF%94%E5%AF%B9-diffVNode"><span class="toc-text">2. 当新旧节点为同一节点时，开始正式的比对 (diffVNode)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E5%AD%90%E7%BA%A7%E5%88%97%E8%A1%A8-diffChildren"><span class="toc-text">比对子级列表 (diffChildren)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%BD%AE%E6%AF%94%E5%AF%B9"><span class="toc-text">第一轮比对:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%BD%AE%E6%AF%94%E5%AF%B9"><span class="toc-text">第二轮比对:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%BD%AE%E6%AF%94%E5%AF%B9"><span class="toc-text">第三轮比对:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E8%BD%AE%E6%AF%94%E5%AF%B9"><span class="toc-text">第四、五轮比对:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-text">实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-props%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">1.props的传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B8%B2%E6%9F%93%E6%A0%91%E7%BB%93%E6%9E%84%E7%A8%B3%E5%AE%9A"><span class="toc-text">2. 渲染树结构稳定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-key-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3. key 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">4. 组件化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%99-%E4%BC%91%E6%86%A9%E4%B9%8B%E5%9C%B0-%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3"><span class="toc-text">第六站: 休憩之地 - 总结归纳</span></a></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Basil</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/React/">React</a></div><div id="post-meta">发布于&nbsp;<time datetime="2018-08-12T11:28:26.000Z">2018-08-12</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>React-原理揭秘实践(上)</span></h1>
<p>用实践来揭开 React 的神秘面纱~</p>
<span id="more"></span>

<h2 id="第一站-穿越之门-JSX"><a href="#第一站-穿越之门-JSX" class="headerlink" title="第一站: 穿越之门 - JSX"></a>第一站: 穿越之门 - JSX</h2><p>作为一名前端，我们需要实现一个个展示给用户的页面。因此视图层便是我们的工作之始。前端领域不断地快速发展，最终都是为了解答 <strong>如何更高效地开发更完美的页面</strong>。而 <code>React</code> 就是答案之一，其中 <code>JSX</code> 便是重要的第一站。</p>
<p>那什么是 <code>JSX</code> 呢？</p>
<p><strong><code>JSX</code> 就是在 <code>JS</code> 环境中约定的一种类 <code>HTML</code> 或 <code>XML</code> 的 动态模板语法，有着极高的 可读性 与 可拓展性，目的是 为了能更便捷地使用 JS 搭建视图结构与布局。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是 JSX</span></span><br><span class="line"><span class="keyword">const</span> jsx = <span class="xml"><span class="tag">&lt;<span class="name">JSX</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">JSX</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>这是一种新全新的 <code>JS</code> 语法，不属于标准，成功地把类 <code>HTML</code> 的标签型模板语法引入 JS 中，创造了一种全新高效的开发模式。但即使最新版的 V8 引擎也无法支持，那怎么执行呢？钥匙就是 <strong>预编译</strong>！得益于 <code>Babel</code> 的强大，我们可以通过 **预编译，将代码编译成浏览器看得懂的 <code>JS</code>**。</p>
<h3 id="babel-plugin-transform-jsx"><a href="#babel-plugin-transform-jsx" class="headerlink" title="babel-plugin-transform-jsx"></a>babel-plugin-transform-jsx</h3><p>这是 <code>Babel</code> 的一款插件，主要的功能就是编译 <code>JSX</code>，直接配置即可 (对编译感兴趣的童鞋，可以继续深入下了解下 <code>Babel</code> 的编译原理，这里就不作展开了)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包工具中的 babel loader 配置</span></span><br><span class="line"><span class="attr">use</span>: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [[<span class="string">&quot;transform-jsx&quot;</span>, &#123;</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: <span class="string">&quot;ReactWebGL.createElement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;useVariables&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;]],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完毕，我们先来写段 <code>JSX</code> 试试。由于我们不使用 <code>DOM</code> 了，视图层被直接绘制于 <code>canvas</code> 上，就自然不能使用常规的 <code>HTML</code> 标签了。我们先来定个容器标签 (<code>&lt;Container&gt;</code>)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Container</span> <span class="attr">name</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    ReactWebGL Hello World</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Container</span> <span class="attr">name</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>咦。秒报错。先不管，我们来看下编译后的文件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsx = ReactGL.createElement(&#123;</span><br><span class="line">  <span class="attr">elementName</span>: Container,</span><br><span class="line">  <span class="attr">attributes</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;parent&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    <span class="string">&quot;ReactWebGL Hello World&quot;</span>,</span><br><span class="line">    ReactWebGL.createElement(&#123;</span><br><span class="line">      <span class="attr">elementName</span>: Container,</span><br><span class="line">      <span class="attr">attributes</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;child&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">children</span>: [<span class="string">&quot;Child&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>原来如此，其实 <code>Babel</code> 做的，就是把上面的 <code>JSX</code> 模板代码, 解析并提取出标签的信息后，转换成常规的函数形式。这个函数就是我们配置中指定的 <code>ReactWebGL.createElement</code>。</p>
<p>接下来我们来看下报错。很明显，是因为在上下文中有一些变量没有进行定义，那接下来我们先定义上:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于编译是直接 变量传递</span></span><br><span class="line"><span class="comment">// 因此标签名作为一个变量需要先定义为 string；</span></span><br><span class="line"><span class="keyword">const</span> Container = <span class="string">&quot;Container&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配配置中的 `ReactWebGL.createElement`</span></span><br><span class="line"><span class="keyword">const</span> ReactWebGL = &#123;</span><br><span class="line">  <span class="function"><span class="title">createElement</span>(<span class="params">tag</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tag);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第二站-天空之城-Virtual-DOM"><a href="#第二站-天空之城-Virtual-DOM" class="headerlink" title="第二站: 天空之城 - Virtual DOM"></a>第二站: 天空之城 - Virtual DOM</h2><p>来到第二站: 什么是 <strong>虚拟 DDM</strong> 呢？</p>
<p>顾名思义，<strong>它并不是真正的视图元素，而是将真实的视图元素抽象为一个 Javascript 对象，包含完整描述了一个真实元素的所有信息，但并不具备渲染功能</strong>。同时由于 <code>DOM</code> 本身便是 <strong>树形结构</strong>，因此使用 <code>Javascript</code> 对象便能很好对整个页面结构进行描述。</p>
<p>刚才 <code>JSX</code> 编译后，参数便是一个最简单的 <strong>虚拟 DOM</strong> 对象(我们称为 <code>VNode</code>):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个最简单的 VNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Container&#x27;</span></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子级列表</span></span><br><span class="line">    <span class="attr">children</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其实只是一个普通的 <code>Javascript</code> 对象，那为什么要设计它呢 ？可能很多人都会有这种观念: <strong>虚拟 DOM 快啊，diff 算法非常厉害，直接操作真实的 DOM 消耗很大。</strong></p>
<p>掐指一算，事情并没有那么简单，听我细细道来 🧐。想象下，当出现以下场景时:</p>
<ul>
<li><p><strong>初次渲染</strong>:</p>
<ul>
<li><p>解析 <code>JSX</code>，生成 <strong>虚拟 DOM 树</strong>，然后经过各种计算，最终调用 <code>DOM</code> 绘制一个个视图元素；</p>
</li>
<li><p>很明显，我们通过 <code>HTML</code> 或 <code>innerHTML</code> 直接创建元素会更快，且白屏时间更短，多了上层的 <strong>计算消耗与内存消耗</strong>，反而是一种 <strong>性能损耗</strong>；</p>
</li>
</ul>
</li>
<li><p><strong>极小更新</strong>:</p>
<ul>
<li><p>需要修改一个标题文案，调用 <code>setState</code> 触发更新。此时，<code>React</code> 并不知道新的 <code>state</code> 会引起多大的变动，需要经过全局逐一的 <code>diff</code> 确定变动的元素再触发更新。</p>
</li>
<li><p>相较而言，获取对应标题元素修改，省去 <code>diff</code>，会更直接高效。那这么说来，<strong>虚拟 DOM</strong> 反而变慢了，那为什么还要用它呢？</p>
</li>
</ul>
</li>
</ul>
<p>如果你的场景是 大量且分散 地更新页面中的元素，那 <strong>虚拟 DOM</strong> 能大大减少其业务逻辑的复杂度，达到一个比较高的消耗性价比。直接操作 <code>DOM</code> 元素，一来逻辑复杂，代码健壮性弱；二来错误的操作反而可能导致更差的性能。</p>
<p>所以快慢并不是衡量 <strong>虚拟 DOM</strong> 价值的因素，其价值更多在于:</p>
<ul>
<li><p><strong>虚拟 DOM</strong> 其实是一种 <strong>牺牲最小性能与空间，换取 架构优化 的方式</strong>，能较大提升项目的可拓展性与可维护性；</p>
</li>
<li><p>对 <code>DOM</code> 的操作进行 <strong>集中化管理</strong>，更加安全稳定且高效；</p>
</li>
<li><p><strong>渲染</strong> 与 <strong>逻辑</strong> 的解耦，高度的 <strong>组件化</strong> 与 <strong>模块化</strong>，提升了代码复用性及开发效率；</p>
</li>
<li><p><strong>虚拟 DOM</strong> 是一种抽象化的对象，可以对接不同的渲染层，完成 <strong>跨平台渲染</strong>。例如 <code>RN / SSR</code> 等方案；</p>
</li>
</ul>
<p><code>JSX</code> 仅仅是一种 <strong>独立的动态模板语法</strong>，通过编译转化为 <strong>虚拟 DOM</strong>，跟 <code>React</code> 并无耦合。因此可以将其 <strong>接入到任意环境或者框架</strong>，例如我们也可以在 <code>Vue</code> 中使用 <code>JSX</code>。</p>
<p>聊完 <strong>虚拟 DOM</strong>，我们回归主线。需要先来设计一个最简单的 <code>VNode</code> 结构，以刚才 <code>Babel</code> 编译出的结构为基础，加上额外的值，方便渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VNode 定义</span></span><br><span class="line">interface VNode &#123;</span><br><span class="line">    <span class="comment">// 标签类型</span></span><br><span class="line">    <span class="attr">type</span>: any,</span><br><span class="line">    <span class="comment">// 标签属性</span></span><br><span class="line">    <span class="attr">props</span>: &#123; [key: string]: any &#125;,</span><br><span class="line">    <span class="comment">// 子级列表</span></span><br><span class="line">    <span class="attr">children</span>: VNode[],</span><br><span class="line">    <span class="comment">// 唯一标识</span></span><br><span class="line">    <span class="attr">key</span>: string</span><br><span class="line">    <span class="comment">// 获取视图元素</span></span><br><span class="line">    <span class="attr">ref</span>: any</span><br><span class="line">    <span class="comment">// 视图元素</span></span><br><span class="line">    <span class="attr">elm</span>: any</span><br><span class="line">    <span class="comment">// 文本内容</span></span><br><span class="line">    <span class="attr">text</span>: string | number | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VNode 生产函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props, ref, key, children, elm, text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        props,</span><br><span class="line">        children,</span><br><span class="line">        ref,</span><br><span class="line">        key,</span><br><span class="line">        elm,</span><br><span class="line">        text,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在定义了 <code>VNode</code> 后，我们就可以开始编写对应的生成函数(<code>createElement</code>)了。</p>
<h2 id="第三站-转换之桥-createElement"><a href="#第三站-转换之桥-createElement" class="headerlink" title="第三站: 转换之桥 - createElement"></a>第三站: 转换之桥 - createElement</h2><p>这个函数就是传说中的 <code>h</code> 函数，用于 <strong>模板 到 虚拟 DOM 之间的桥梁</strong>。在现在的大多数主流 <strong>虚拟 DOM</strong> 库中，都拥有该函数。在 <code>React</code> 中，它是通过 <code>Babel</code> 将 <code>JSX</code> 编译成 <code>h</code> 函数，即 <code>React.createElement</code>。而在 <code>Vue</code> 中，则是通过 <code>vue-loader</code> 将 <code>&lt;template&gt;</code> 编译成其 <code>h</code> 函数。该函数主要功能是:</p>
<p><strong>加工生成完整的 虚拟 DOM 树</strong>，用于后面的渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">elementName</span>: type, <span class="attr">attributes</span>: data, children &#125; = tag;</span><br><span class="line">  <span class="keyword">const</span> &#123; key, ref, ...props &#125; = data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理文本内容</span></span><br><span class="line">  <span class="keyword">let</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理子级列表中的 string or number</span></span><br><span class="line">  <span class="comment">// 同样转换为 VNode</span></span><br><span class="line">  <span class="keyword">if</span> (children &amp;&amp; children.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> i,</span><br><span class="line">      l = children.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> child = children[i];</span><br><span class="line">      <span class="keyword">if</span> ([<span class="string">&quot;string&quot;</span>, <span class="string">&quot;number&quot;</span>].includes(<span class="keyword">typeof</span> child)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&quot;Text&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">// 基于 WebGL 的需要，区别于 DOM</span></span><br><span class="line">          <span class="comment">// 这里新增一个 &lt;Text&gt; 标签，vnode.type === &#x27;Text&#x27;</span></span><br><span class="line">          <span class="comment">// 需特殊处理</span></span><br><span class="line">          <span class="keyword">if</span> (text === <span class="literal">undefined</span>) text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          text += <span class="built_in">String</span>(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非标签的文字节点， vnode.type === undefined</span></span><br><span class="line">          <span class="comment">// 例如 &lt;Container&gt;Text&lt;/Container&gt;</span></span><br><span class="line">          <span class="comment">// 中间的 Text 其实是同样需要一个文字元素</span></span><br><span class="line">          children[i] = vnode(</span><br><span class="line">            <span class="literal">undefined</span>,</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            <span class="literal">undefined</span>,</span><br><span class="line">            <span class="literal">undefined</span>,</span><br><span class="line">            <span class="literal">undefined</span>,</span><br><span class="line">            <span class="literal">undefined</span>,</span><br><span class="line">            <span class="built_in">String</span>(children[i])</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode(type, props, ref, key, children, <span class="literal">undefined</span>, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行，Perfect！打印下 <code>JSX</code>，可以看到一棵转换后的 <code>VNode Tree</code>，并且包含我们模板标签中的所有完整信息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd034c84e81ad?w=357&h=588&f=jpeg&s=23458"></p>
<p style="text-align: center; font-weight: bold;">图1. VNode Tree</p>

<h3 id="WebGL-API"><a href="#WebGL-API" class="headerlink" title="WebGL API"></a>WebGL API</h3><p>为了更好地 <strong>解耦视图层</strong>，我们把需要用到的一些与 <code>WebGL</code> 相关的 <code>API</code> 简单包裹下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Api = &#123;</span><br><span class="line">  <span class="comment">// 根据 标签类型 创建 视图元素</span></span><br><span class="line">  <span class="function"><span class="title">createElement</span>(<span class="params">vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PIXI[vnode.type]();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 创建、设置 文本元素</span></span><br><span class="line">  <span class="function"><span class="title">createTextElement</span>(<span class="params">vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">text</span>: content = <span class="string">&quot;&quot;</span>, style &#125; = vnode;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PIXI.Text(content, style);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setTextContent</span>(<span class="params">elm, content</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elm &amp;&amp; [<span class="string">&quot;string&quot;</span>, <span class="string">&quot;number&quot;</span>].includes(<span class="keyword">typeof</span> content)) &#123;</span><br><span class="line">      elm.text = content;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取父级</span></span><br><span class="line">  <span class="function"><span class="title">parentNode</span>(<span class="params">elm</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elm &amp;&amp; elm.parent;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 添加、删除子级</span></span><br><span class="line">  <span class="function"><span class="title">appendChild</span>(<span class="params">parent, child</span>)</span> &#123;</span><br><span class="line">    parent.addChild(child);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">removeChild</span>(<span class="params">parent, child</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (child &amp;&amp; child.parent) &#123;</span><br><span class="line">      parent.removeChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取下一个兄弟元素</span></span><br><span class="line">  <span class="function"><span class="title">nextSibling</span>(<span class="params">elm</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = Api.parentNode(elm);</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = parent.children.indexof(elm);</span><br><span class="line">      <span class="keyword">return</span> parent.children[index + <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插入到指定元素之前</span></span><br><span class="line">  <span class="function"><span class="title">insertBefore</span>(<span class="params">parentElm, newElm, referenceElm</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (referenceElm) &#123;</span><br><span class="line">      <span class="keyword">const</span> refIndex = parentElm.children.indexOf(referenceElm);</span><br><span class="line">      parentElm.addChildAt(newElm, refIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Api.appendChild(parentElm, newElm);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一部分可以称为 <strong>对接层</strong>，可以对接到各个平台，如果使用原生 <code>DOM</code> 的 <code>API</code>，则就是 <code>Web</code> 渲染，有点类似于 <code>react-dom</code> 所完成的事。</p>
<p>为了演示方便，我们就使用 <code>pixi.js</code> 来作为 <strong>渲染接口</strong>。这里与 <code>WebGL</code> 库无关，可以对接到 <strong>任意渲染框架</strong>。</p>
<h2 id="第四站-创造之柱-Render"><a href="#第四站-创造之柱-Render" class="headerlink" title="第四站: 创造之柱 - Render"></a>第四站: 创造之柱 - Render</h2><p>有了 <strong>接口层 API</strong> 与 <code>VNode</code> 后，可以开始 <strong>创建真实视图元素</strong>，并同时根据 <code>vnode.props</code> <strong>同步属性并绑定事件</strong>。最后 <strong>递归创建子级</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 vnode 创建 视图元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children, type, text, props &#125; = vnode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vnode 的 type 为字符串时，表示其为 元素节点</span></span><br><span class="line">  <span class="comment">// 依照 type 创建 视图元素</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; <span class="keyword">typeof</span> type === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用接口</span></span><br><span class="line">    vnode.elm = Api.createElement(vnode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归创建子级元素，并添加到父元素中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="comment">// 创建子级</span></span><br><span class="line">      <span class="keyword">let</span> i,</span><br><span class="line">        l = children.length;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">        Api.appendChild(vnode.elm, createElm(children[i]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="literal">undefined</span> &amp;&amp; text) &#123;</span><br><span class="line">    <span class="comment">// 被非 &lt;Text&gt; 包裹的文字节点</span></span><br><span class="line">    vnode.elm = Api.createTextElement(vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素创建成功时，执行设置属性</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.elm) setProps(vnode.elm, props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode.elm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性处理</span></span><br><span class="line"><span class="comment">// 将 虚拟DOM 上的属性同步设置到 上面创建的真实元素 elm 上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProps</span>(<span class="params">elm, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elm &amp;&amp; <span class="keyword">typeof</span> props === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(props);</span><br><span class="line">    <span class="keyword">let</span> l = keys.length,</span><br><span class="line">      i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[i];</span><br><span class="line">      <span class="keyword">const</span> value = props[key];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 事件绑定</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> evName = key.substring(<span class="number">2</span>).toLowerCase();</span><br><span class="line">          elm.on(evName, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 属性设置</span></span><br><span class="line">        elm[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以开始渲染 <code>VNode</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, parent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据 vnode 创建出对应的元素</span></span><br><span class="line">  <span class="keyword">const</span> elm = createElm(vnode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 并添加到容器中即可</span></span><br><span class="line">  Api.appendChild(parent, elm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成，到这里我们已经成功完成把 <code>JSX</code> 的初次渲染了。那下一步的需求就是: <strong>如何更新视图呢？</strong> 这里就是传说中的 <code>Diff</code> 算法的用武之地了！</p>
<h2 id="第五站-时空之匙-Diff"><a href="#第五站-时空之匙-Diff" class="headerlink" title="第五站: 时空之匙 - Diff"></a>第五站: 时空之匙 - Diff</h2><p>说到 <strong>虚拟 DOM</strong> 就马上能提到其核心的 <code>diff</code> 算法。当我们通过 <code>setState</code> 去更新组件时，是重新生成一棵全新的完整 <strong>虚拟 DOM 树</strong>，此时就需要对比 <strong>新旧两棵树的差异点</strong>，再针对性更新。也就是一种 <strong>计算得出两个对象差异</strong> 的算法。</p>
<p>这种 <code>diff</code> 算法其实使用的场景很多，例如我们很熟悉的代码版本控制。前后两份提交的代码需要比对出差异点，然后进行更新保存。只不过这里的 <strong>代码文件</strong> 变成了 <strong>虚拟 DOM</strong>。由于 <strong>虚拟 DOM</strong> 相当复杂，包含非常多的属性，并且可能拥有非常深的层级，因此如果用常规的循环递归去比较，时间复杂度为 <code>O(n^3)</code>，这性能是无法接受的。</p>
<p>因此天才工程师们基于 Web 视图渲染的一些特征，在比对上通过 <strong>制定规则，选择性取舍</strong>，大大优化了算法的效率。包含以下三种优化策略:</p>
<h3 id="1-同层比对策略"><a href="#1-同层比对策略" class="headerlink" title="1. 同层比对策略"></a>1. 同层比对策略</h3><p>由于在大部分 Web 视图渲染中，我们很少会去跨层级移动元素，移动元素通常出现在同层级的列表中，因此这里可以有一个优化策略:</p>
<p><strong>只做同层级的比对，忽略跨层级的元素移动</strong>。</p>
<p>传统的 <code>diff</code> 算法需要两层循环，每两个节点之间都需要进行对比。而制定了同层比对后，节点只需要跟同一层级的节点进行比对，如下图所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd046b8a7cfcd?w=1068&h=622&f=jpeg&s=37416"></p>
<p style="text-align: center; font-weight: bold;">图2. diff 比对策略</p>

<p>此时，性能已经大大的提升了，时间复杂度优化成 <code>O(n^2)</code>。另外，<strong>如果真出现跨层级移动时，会直接将旧元素删除，在新的位置重新创建，也能保证更新的准确行。但可能会导致状态的丢失。</strong></p>
<h3 id="2-唯一标识策略"><a href="#2-唯一标识策略" class="headerlink" title="2. 唯一标识策略"></a>2. 唯一标识策略</h3><p>虽然我们做了同层比对的优化，但此时有一个问题:</p>
<p>例如图 2，当 <code>C1</code> / <code>C2</code> 交换位置，我们在循环比对时，由于它们均属于相同类型的节点，单单通过 type 并无法正确区分，无法识别出位置的移动。只能做到把 <code>C1</code> 修改成 <code>C2</code>，把 <code>C2</code> 修改成 <code>C1</code>。这样不仅会 <strong>损耗性能</strong>，而且可能导致 <strong>状态丢失</strong>。</p>
<p>最优的方式应该就是: 把 <code>C1</code> 与 <code>C2</code> 正确交换位置。关键点就在于: <strong>如何正确识别与区分节点</strong>。因此这里便引入了 <code>key</code> 作为唯一标识，用 <code>type</code> + <code>key</code> 便可确切地识别出节点的准确位置，从而将时间复杂度优化成了 <code>O(n)</code>。</p>
<h3 id="3-组件模式策略"><a href="#3-组件模式策略" class="headerlink" title="3. 组件模式策略"></a>3. 组件模式策略</h3><p>在复杂度方面，已经有了有效的优化。接下来，便是从逻辑层进行优化。</p>
<p>首先一个最大的损耗就是: 无法准确定位目标节点，需要 <strong>树遍历</strong> 寻找更新的目标节点。</p>
<p>如图 2，我们只要更新 <strong><code>D</code>节点</strong>，却必须从最根级的 <strong><code>A</code>节点</strong> 逐层 <code>diff</code>，完整比对新旧两棵 虚拟树，这里有明显的无谓损耗。如果将 <strong><code>D</code>节点</strong> 抽离成一个独立的模块，则可以只调用 <strong><code>D</code>节点</strong> 自身的 <code>diff</code>。 因此便引入了 <strong>组件模式</strong>，能够 <strong>碎片化 虚拟 DOM</strong>。</p>
<p>如果我们确实需要同时更新 <strong><code>A</code> / <code>D</code></strong> 节点呢？其实左边分支 <code>B1</code> 节点并不需要更新，不需要 <code>diff</code>。如果能让 <code>B1</code> 节点拥有一个标识标识自己为非更新目标，在更新流中可以 <strong>主动打断更新流</strong>。那就可以只 <code>diff</code> <code>A</code> -&gt; <code>B2</code> -&gt; <code>D</code> 这条线了。这里，便是我们熟知的 <code>shouldComponentUpdate</code>。</p>
<h3 id="Diff-的实现"><a href="#Diff-的实现" class="headerlink" title="Diff 的实现"></a>Diff 的实现</h3><p>首先我们先来梳理下两个 <code>VNode diff</code> 可能出现的情况:</p>
<ul>
<li>非同类型节点：<ul>
<li>直接 <strong>创建新元素</strong> 并 <strong>替换旧元素</strong>；</li>
</ul>
</li>
<li>同类型节点：<ul>
<li><strong>更新属性、事件</strong>；</li>
<li><strong>递归更新子级列表</strong>；</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd04a1c761185?w=1450&h=1042&f=jpeg&s=46707"></p>
<p style="text-align: center;font-weight: bold;">图3. diff 流程图</p>

<p>根据这个流程图，我们可以先从入口开始实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldVNode, newVNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSameVNode(oldVNode, newVNode)) &#123;</span><br><span class="line">        <span class="comment">// 开始 diff</span></span><br><span class="line">        <span class="comment">// 	diffVNode</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新节点替换旧节点</span></span><br><span class="line">        <span class="comment">// replaceVNode</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 type || key 判断是否为同类型节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameVNode</span>(<span class="params">oldVNode, newVNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oldVNode.key === newVNode.key &amp;&amp; oldVNode.type === newVNode.type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-当新旧节点不同时，直接替换-replaceVNode"><a href="#1-当新旧节点不同时，直接替换-replaceVNode" class="headerlink" title="1. 当新旧节点不同时，直接替换 (replaceVNode)"></a>1. 当新旧节点不同时，直接替换 (<code>replaceVNode</code>)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceVNode</span>(<span class="params">oldVNode, newVNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 移除旧元素</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">elm</span>: oldElm &#125; = oldVNode;</span><br><span class="line">  <span class="keyword">const</span> parent = Api.parentNode(oldElm);</span><br><span class="line">  Api.removeChild(parent, oldElm);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新元素，并添加到父级中</span></span><br><span class="line">  <span class="keyword">const</span> newElm = createElm(newVNode);</span><br><span class="line">  Api.appendChild(parent, newElm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-当新旧节点为同一节点时，开始正式的比对-diffVNode"><a href="#2-当新旧节点为同一节点时，开始正式的比对-diffVNode" class="headerlink" title="2. 当新旧节点为同一节点时，开始正式的比对 (diffVNode)"></a>2. 当新旧节点为同一节点时，开始正式的比对 (<code>diffVNode</code>)</h3><p>根据上面的流程图，我们也能明白这里我们要做以下这些事:</p>
<ul>
<li><p><strong>比对属性与事件</strong> (<code>diffProps</code>)；</p>
</li>
<li><p><strong>递归比对子级列表</strong>: 这里也有三种情况；</p>
<ul>
<li><p>新旧节点 <strong>均有子级列表</strong>，则进入 <strong>列表比对</strong> (<code>diffChildren</code>)；</p>
</li>
<li><p><strong>旧节点没有</strong> 子级，<strong>新节点有</strong> 子级，则 直接 <strong>新增</strong> 新子级 (<code>addVNodes</code>)；</p>
</li>
<li><p><strong>旧节点有</strong> 子级，<strong>新节点没有</strong> 子级，则 直接 <strong>删除</strong> 旧子级 (<code>removeVNodes</code>)；</p>
</li>
</ul>
</li>
</ul>
<p>根据以上梳理，我们先来实现 <code>diffVNode</code> 这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffVNode</span>(<span class="params">oldVNode, newVNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; elm, <span class="attr">children</span>: oldChild, <span class="attr">text</span>: oldText, <span class="attr">props</span>: oldProps &#125; = oldVNode;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">children</span>: newChild, <span class="attr">text</span>: newText, <span class="attr">props</span>: newProps &#125; = newVNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldVNode === newVNode || !elm) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 已判断为同一节点，目的为 更新元素</span></span><br><span class="line">  <span class="comment">// 因此直接复用旧元素</span></span><br><span class="line">  newVNode.elm = elm;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对属性与事件</span></span><br><span class="line">  diffProps(elm, oldProps, newProps);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hasOldChild = !!(oldChild &amp;&amp; oldChild.length);</span><br><span class="line">  <span class="keyword">const</span> hasNewChild = !!(newChild &amp;&amp; newChild.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断为 元素节点 或者 文字节点</span></span><br><span class="line">  <span class="keyword">if</span> (newText === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 元素节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断如何更新子级</span></span><br><span class="line">    <span class="keyword">if</span> (hasOldChild &amp;&amp; hasNewChild) &#123;</span><br><span class="line">      <span class="comment">// 新旧节点均存在子级列表时，直接 diff 列表</span></span><br><span class="line">      <span class="keyword">if</span> (oldChild !== newChild) &#123;</span><br><span class="line">        <span class="comment">// diff 列表</span></span><br><span class="line">        diffChildren(elm, oldChild, newChild);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasNewChild) &#123;</span><br><span class="line">      <span class="comment">// 旧节点 不包含子级，而新节点包含子级</span></span><br><span class="line">      <span class="comment">// 则直接新增新子级</span></span><br><span class="line">      addVNodes(elm, <span class="literal">null</span>, newChild, <span class="number">0</span>, newChild.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasOldChild) &#123;</span><br><span class="line">      <span class="comment">// 新子级不包含元素，而旧节点包含子级</span></span><br><span class="line">      <span class="comment">// 则需要删除旧子级</span></span><br><span class="line">      removeVNodes(elm, oldChild, <span class="number">0</span>, oldChild.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldText !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 当新旧均无子级</span></span><br><span class="line">      <span class="comment">// 这里有可能存在 &lt;Text&gt; 标签，且新内容为空</span></span><br><span class="line">      <span class="comment">// 因此直接清空旧元素文字</span></span><br><span class="line">      Api.setTextContent(elm, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldText !== newText) &#123;</span><br><span class="line">    <span class="comment">// 文字节点</span></span><br><span class="line">    <span class="comment">// 当新旧文字内容不同时，直接修改内容</span></span><br><span class="line">    Api.setTextContent(elm, newText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">elm, oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldProps === newProps || !elm) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> oldProps === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> newProps === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(oldProps),</span><br><span class="line">      i,</span><br><span class="line">      l = keys.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置被删除的旧属性</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[i];</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key],</span><br><span class="line">        newValue = newProps[key];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当存在旧事件，且新旧值不一致时</span></span><br><span class="line"><span class="comment">         * 事件解绑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> oldValue === <span class="string">&quot;function&quot;</span> &amp;&amp; oldValue !== newValue) &#123;</span><br><span class="line">          <span class="keyword">const</span> evName = key.substring(<span class="number">2</span>).toLowerCase();</span><br><span class="line">          elm.off(evName, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 属性被赋值时会被自动重置</span></span><br><span class="line"><span class="comment">         * 只需要重置被删除的属性即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (newValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="comment">// 元素属性默认值</span></span><br><span class="line">          elm[key] = DEFAULT_PROPS[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置新属性</span></span><br><span class="line">    setProps(elm, newProps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比对子级列表-diffChildren"><a href="#比对子级列表-diffChildren" class="headerlink" title="比对子级列表 (diffChildren)"></a>比对子级列表 (<code>diffChildren</code>)</h2><p>其实比对属性、事件都是相对简单的，而 <strong>子级列表的比对，才是整个 diff 算法中最核心且最考验性能的部分</strong>，因此这里的列表比对算法决定了整个更新渲染的性能。在 <strong>虚拟 DOM</strong> 刚出现时，使用的是比较简单的 <strong>深度优先(DFS) + 排序比对</strong> 的方式。后来出现了更为高效且沿用至今的 <strong>两端比对算法 + Key 值比对</strong>，直接把 <code>diff</code> 的效率提高了一个层级，且更好理解，有三种优先级不同的比对策略:</p>
<ul>
<li><p>优先从新旧列表的 <strong>两端</strong> 的 <strong>四个节点</strong> 开始进行 <strong>两两比对</strong>；</p>
</li>
<li><p>如果均不匹配，则尝试 <strong>key 值比对</strong>；</p>
<ul>
<li><p>如 <strong>key 值</strong> 匹配上，则移动并更新节点；</p>
</li>
<li><p>如 未匹配上，则在对应的位置上 <strong>新增新节点</strong>；</p>
</li>
</ul>
</li>
<li><p>最后全部比对完后，列表中 <strong>剩余的节点</strong> 执行 <strong>删除或新增</strong>；</p>
</li>
</ul>
<p>这里这么说大家是不是一脸懵 🤣。没事，先稍微理解下就行。我们接下来直接用动画来更直观地看下两端比较算法的具体过程。这里就以刚才 图 2 的子级列表为例，即:</p>
<ul>
<li><p>oldChildren 包含 5 个子级节点: <code>[A, B, C, D, E]</code>；</p>
</li>
<li><p>newChildren 的子级修改为: <code>[F, C, B, D, A]</code>；</p>
</li>
</ul>
<blockquote>
<p>Tips:</p>
<p>如新旧列表中的 A，代表这两个节点为 <strong>同类型节点</strong>，即节点的 <code>type / key</code> 均相等；</p>
</blockquote>
<h3 id="第一轮比对"><a href="#第一轮比对" class="headerlink" title="第一轮比对:"></a>第一轮比对:</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd04d40973064?w=750&h=389&f=gif&s=941267"></p>
<p style="text-align: center; font-weight: bold;">图4. diff 第一轮循环</p>

<ul>
<li><p><strong>1.</strong> 优先从新旧列表的两端正向开始，<strong>不相同</strong>: <code>A !== F</code> 且 <code>E !== A</code>；</p>
</li>
<li><p><strong>2.</strong> 两端交叉比对，发现 <strong>旧列表的第一项与新列表的末项相同</strong> (<code>isSameVNode</code>):</p>
<ul>
<li><p>把旧列表中的第一项 <strong>移动</strong> 到最后一项；</p>
</li>
<li><p>继续递归 diff 新旧 <code>A</code>；</p>
</li>
</ul>
</li>
</ul>
<h3 id="第二轮比对"><a href="#第二轮比对" class="headerlink" title="第二轮比对:"></a>第二轮比对:</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd0505762e643?w=585&h=350&f=gif&s=724488"></p>
<p style="text-align: center; font-weight: bold;">图5. diff 第二轮循环</p>

<ul>
<li><p><strong>1.</strong> 同样，优先从两端正向比对，<code>B !== F &amp; E !== D</code>；</p>
</li>
<li><p><strong>2.</strong> 两端交叉比对，<code>B !== D &amp; E !== F</code>；</p>
</li>
<li><p><strong>3.</strong> 进入 <strong>key 比对</strong>:</p>
<ul>
<li><p>固定取 **新列表首项 (<code>F</code>)**；</p>
</li>
<li><p>循环与旧列表 <strong>key 列表</strong> 逐项比对，均 <strong>无法匹配</strong>；</p>
</li>
<li><p>因此为 <strong>新节点</strong>，直接 <strong>创建并添加到旧列表首项</strong>；</p>
</li>
</ul>
</li>
</ul>
<h3 id="第三轮比对"><a href="#第三轮比对" class="headerlink" title="第三轮比对:"></a>第三轮比对:</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd0542e834ceb?w=750&h=410&f=gif&s=692139"></p>
<p style="text-align: center; font-weight: bold;">图6. diff 第三轮循环</p>

<ul>
<li><p><strong>1.</strong> 两端正向、交叉比对，不匹配；</p>
</li>
<li><p><strong>2.</strong> 进入 <strong>key 比对</strong>；</p>
<ul>
<li><p>固定取 **新列表首项 (<code>C</code>)**；</p>
</li>
<li><p>循环与旧列表逐项比对，<strong>匹配</strong> 到旧列表第二项；</p>
</li>
<li><p>则把旧列表中的第二项 <strong>移动到首项</strong>，并继续 递归继续 diff 新旧 <code>C</code>；</p>
</li>
</ul>
</li>
</ul>
<h3 id="第四、五轮比对"><a href="#第四、五轮比对" class="headerlink" title="第四、五轮比对:"></a>第四、五轮比对:</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-gold-cdn.xitu.io/2020/3/9/170bd057514a585e?w=750&h=420&f=gif&s=814595"></p>
<p style="text-align: center; font-weight: bold;">图7. diff 第四五轮循环</p>

<ul>
<li><p><strong>1.</strong> 首项比对，匹配成功；</p>
<ul>
<li><p>递归继续 diff 新旧 <code>B</code>；</p>
</li>
<li><p>移动下标，进入下一轮比对；</p>
</li>
</ul>
</li>
<li><p><strong>2.</strong> 同样首项比对匹配；</p>
<ul>
<li><p>递归继续 diff 新旧 <code>D</code>；</p>
</li>
<li><p>移动下标，进入下一轮比对；</p>
</li>
</ul>
</li>
<li><p><strong>3.</strong> 新列表循环已结束，<strong>删除</strong> 旧列表中的剩余节点；</p>
</li>
</ul>
<p>经过了五轮的比对，旧列表已经被成功更新。为了包含我们上面解释的三种策略，举例时用的是复杂度较高，较少出现的场景。在日常业务中，大部分都会更简单，性能表现会更好。接下来，我们把这个算法用代码实现下，采用 <strong>双列表游标 + while 循环</strong> 的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">parentElm, oldChild, newChild</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新子级列表</span></span><br><span class="line"><span class="comment">   * 双列表游标 + while</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化游标</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>,</span><br><span class="line">    newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldChild.length - <span class="number">1</span>,</span><br><span class="line">    newEndIdx = newChild.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列表首尾节点</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVNode = oldChild[<span class="number">0</span>],</span><br><span class="line">    oldEndVNode = oldChild[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> newStartVNode = newChild[<span class="number">0</span>],</span><br><span class="line">    newEndVNode = newChild[newEndIdx];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, before;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当起始游标 &lt; 终止游标时，</span></span><br><span class="line"><span class="comment">   * 表示列表中仍有未 diff 的节点</span></span><br><span class="line"><span class="comment">   * 进入循环</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 排除非有效的节点</span></span><br><span class="line"><span class="comment">     * 剔除列表中包含的 undefined || false || null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartVNode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldStartVNode = oldChild[++oldStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldEndVNode = oldChild[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVNode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVNode = newChild[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVNode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newEndVNode = newChild[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameVNode(oldStartVNode, newStartVNode)) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 2. 正反向两两比对列表首项与末项匹配成功</span></span><br><span class="line"><span class="comment">       * 移动游标，递归 diff 两个节点</span></span><br><span class="line"><span class="comment">       * 均未匹配上，则进入 3. key 值比对</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      diff(oldStartVNode, newStartVNode);</span><br><span class="line"></span><br><span class="line">      oldStartVNode = oldChild[++oldStartIdx];</span><br><span class="line">      newStartVNode = newChild[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameVNode(oldEndVNode, newEndVNode)) &#123;</span><br><span class="line">      diff(oldEndVNode, newEndVNode);</span><br><span class="line"></span><br><span class="line">      oldEndVNode = oldChild[--oldEndIdx];</span><br><span class="line">      newEndVNode = newChild[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameVNode(oldStartVNode, newEndVNode)) &#123;</span><br><span class="line">      Api.insertBefore(</span><br><span class="line">        parentElm,</span><br><span class="line">        oldStartVNode.elm,</span><br><span class="line">        Api.nextSibling(oldEndVNode.elm)</span><br><span class="line">      );</span><br><span class="line">      diff(oldStartVNode, newEndVNode);</span><br><span class="line"></span><br><span class="line">      oldStartVNode = oldChild[++oldStartIdx];</span><br><span class="line">      newEndVNode = newChild[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameVNode(oldEndVNode, newStartVNode)) &#123;</span><br><span class="line">      Api.insertBefore(parent, oldEndVNode.elm, oldStartVNode.elm);</span><br><span class="line">      diff(oldEndVNode, newStartVNode);</span><br><span class="line"></span><br><span class="line">      oldEndVNode = oldChild[--oldEndIdx];</span><br><span class="line">      newStartVNode = newChild[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 3. 两端比对均不匹配</span></span><br><span class="line"><span class="comment">       * 进入 key 值比对</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 根据剩余的旧列表创建 key list</span></span><br><span class="line">      <span class="keyword">if</span> (!oldKeyToIdx) &#123;</span><br><span class="line">        oldKeyToIdx = createKeyList(oldChild, oldStartIdx, oldEndIdx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断新列表项的 key值 是否存在</span></span><br><span class="line">      idxInOld = oldKeyToIdx[newStartVNode.key || <span class="string">&quot;&quot;</span>];</span><br><span class="line">      <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 4. 新 key 值在旧列表中不存在</span></span><br><span class="line"><span class="comment">         * 直接将该节点插入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Api.insertBefore(</span><br><span class="line">          parentElm,</span><br><span class="line">          createElm(newStartVNode),</span><br><span class="line">          oldStartVNode.elm</span><br><span class="line">        );</span><br><span class="line">        newStartVNode = newChild[++newStartIdx];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 5. 新 key 在旧列表中存在时</span></span><br><span class="line"><span class="comment">         * 继续判断是否为同类型节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        elmToMove = oldChild[idxInOld];</span><br><span class="line">        <span class="keyword">if</span> (isSameVNode(elmToMove, newStartVNode)) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 6. 新旧节点类型一致</span></span><br><span class="line"><span class="comment">           * key 有效，直接移动并 diff</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          Api.insertBefore(parentElm, elmToMove.elm, oldStartVNode.elm);</span><br><span class="line">          diff(elmToMove, newStartVNode);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 清空旧列表项</span></span><br><span class="line">          <span class="comment">// 后续的比对可以直接跳过</span></span><br><span class="line">          oldChild[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 7. 新旧节点类型不一致</span></span><br><span class="line"><span class="comment">           * key 效，直接创建元素并插入</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          Api.insertBefore(</span><br><span class="line">            parentElm,</span><br><span class="line">            createElm(newStartVNode),</span><br><span class="line">            oldStartVNode.elm</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVNode = newChild[++newStartIdx];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 8. 当有游标列表为空时，则结束循环，进入策略3</span></span><br><span class="line"><span class="comment">   * 当 旧列表为空 时，则创建并插入新列表中的剩余节点</span></span><br><span class="line"><span class="comment">   * 当 新列表为空 时，则删除旧列表中的剩余节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      <span class="comment">// 新增节点</span></span><br><span class="line">      <span class="keyword">const</span> vnode = newChild[newEndIdx + <span class="number">1</span>];</span><br><span class="line">      before = vnode ? vnode.elm : <span class="literal">null</span>;</span><br><span class="line">      addVNodes(parentElm, before, newChild, newStartIdx, newEndIdx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      removeVNodes(parentElm, oldChild, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恭喜童鞋们~ 我们完成了传说中的 <code>两端比对算法</code> 咯 🥳。其实只要按比对的优先级把逻辑理清楚，逐一执行判断，思路还是比较清晰的。</p>
<h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><p>通过上面真正的代码编写以及了解实现原理后，我们其实能从中找到一些好的实践方式，从而优化我们的代码，提高性能。</p>
<h4 id="1-props的传递"><a href="#1-props的传递" class="headerlink" title="1.props的传递"></a>1.<code>props</code>的传递</h4><p><code>JSX</code> 中标签可以传递属性，最简单的方式就是 <strong>值传递</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmp = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Container</span> <span class="attr">text</span>=<span class="string">&quot;text&quot;</span> <span class="attr">data</span>=<span class="string">&#123;&#123;</span> <span class="attr">a:</span> <span class="attr">1</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    Text</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>由于在比对的时候，在判断 <code>props</code> 是否发生变化时，采用 <strong>全等</strong> 的比较。因此，当出现值是 <strong>引用对象</strong> 时，如果直接像上面这样, <code>data</code> 写在 <code>JSX</code> 中，则每次 <code>diff</code> 时 <code>data</code> 的值都是全新的对象，不会相等。即使对象属性全部一致，但每次均需要循环比对每一项属性。</p>
<p>因此建议:</p>
<ul>
<li>当属性值为 <strong>引用对象</strong> 时，如 <code>Object</code>、<code>Array</code>、<code>Function</code>等，直接使用 <strong>引用传递</strong>:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> tmp = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Container</span> <span class="attr">text</span>=<span class="string">&quot;text&quot;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Text</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>同理，当数据需要修改时，不要直接修改源对象，而是应该 <strong>遵循数据不可变原则</strong>，生成一个新对象。</li>
</ul>
<p>这样的建议可以有效降低 <code>diff</code> 时的性能损耗，当场景复杂时，收益就比较可观了。</p>
<h4 id="2-渲染树结构稳定"><a href="#2-渲染树结构稳定" class="headerlink" title="2. 渲染树结构稳定"></a>2. 渲染树结构稳定</h4><p><code>diff</code> 算法采用的 <strong>同层比对</strong> 的策略，因此如果是跨层级的移动，就会 重新创建新节点并删除原来的节点，并不是真正的移动。所以保证 <strong>渲染树结构稳定</strong> 可以有效提高性能。</p>
<ul>
<li><p>尽量避免节点的 <strong>跨层级移动</strong>；</p>
</li>
<li><p>如无法避免，则需要考虑 <strong>状态同步</strong> 的问题；</p>
</li>
<li><p>同层移动同样也会在 <code>diff</code> 时需要额外的循环比对，应该减少不必要的频繁移动；</p>
</li>
</ul>
<h4 id="3-key-的使用"><a href="#3-key-的使用" class="headerlink" title="3. key 的使用"></a>3. key 的使用</h4><p>当需要列表中 <code>VNode</code> 的 <strong>同层移动</strong> 时，加上唯一标识 <code>key</code> 能有效提高 <code>diff</code> 性能，避免元素的 <strong>重渲染</strong>。</p>
<ul>
<li><p>注意确保 <code>VNode.key</code> 在 <code>diff</code> 前后的 <strong>一致</strong>，这样才可有效提升性能，避免使用 <code>index</code>、 <code>Math.random</code>、时间戳等值；</p>
</li>
<li><p>即使在非循环列表渲染时，给标签添加 <code>key</code> 值同样会生效，不同的 <code>key</code> 会导致节点被判定为非同类节点，从而进行替换；</p>
</li>
</ul>
<h4 id="4-组件化"><a href="#4-组件化" class="headerlink" title="4. 组件化"></a>4. 组件化</h4><ul>
<li><p><strong>复用性高</strong> 且需要 <strong>频繁更新</strong> 的节点抽离成 <strong>组件</strong>，会使 <code>VNode Tree</code> 碎片化，从而能更有效地进行 <strong>局部更新</strong>，减少触发 <code>diff</code> 的节点数量，提高性能且提高代码复用率；</p>
</li>
<li><p>但由于组件的创建和 <code>diff</code> 相比普通节点来说更为 <strong>复杂</strong>，需要执行例如生命周期，组件比对 等，所以需要 <strong>合理规划</strong>，避免 <strong>过分组件化</strong> 导致 <strong>内存的浪费和影响性能</strong>，一些 <strong>复用率低的静态元素</strong> 直接使用元素节点更为合理；</p>
</li>
</ul>
<h2 id="第六站-休憩之地-总结归纳"><a href="#第六站-休憩之地-总结归纳" class="headerlink" title="第六站: 休憩之地 - 总结归纳"></a>第六站: 休憩之地 - 总结归纳</h2><p>受篇幅所限，本文暂且完成到这里。先来总结回顾下我们完成的部分:</p>
<ul>
<li><p><strong>1.</strong> <code>JSX</code> 是一种 <strong>动态模板语法</strong>，通过 <code>Babel</code> 编译为 <code>createElement</code> 函数；</p>
</li>
<li><p><strong>2.</strong> <code>createElement</code> 将 <code>JSX</code> 转换为 **虚拟 Dom(VNode)**，包含完整的标签信息 (类型、属性、子级列表)；</p>
</li>
<li><p><strong>3.</strong> <strong>虚拟 DOM</strong> 是一种 <strong>牺牲最小性能与空间，换取 架构优化</strong> 的方式，其 <strong>组件化</strong> 以及 <strong>解耦</strong> 的思想，提高了项目的拓展性、复用性与可维护性，同时为 <strong>跨平台渲染</strong> 奠定基础；</p>
</li>
<li><p><strong>4.</strong> 通过实现 <code>createElm</code> 与 <code>render</code>，完成 <code>VNode</code> 的 <strong>初次渲染</strong>；</p>
</li>
<li><p><strong>5.</strong> <code>Diff</code> 是一种 <strong>计算得出两个 VNode 差异</strong> 的算法，使用 <strong>同层比对、唯一标识、组件模式</strong> 优化了算法比对性能，将时间复杂度降低为 <code>O(n)</code>；</p>
</li>
<li><p><strong>6.</strong> 列表比对 (<code>diffChildren</code>) 采用 <strong>两端比对算法 + Key 值比对</strong> 算法，大大提高了 <code>Diff</code> 效率；</p>
</li>
<li><p><strong>7.</strong> 实现 <code>diffVNode</code>、<code>diffProps</code>、<code>diffChildren</code>，完成 <code>VNode</code> 的 <strong>动态更新</strong>；</p>
</li>
</ul>
<p>我们完成了框架最核心的 <strong><code>JSX</code> - <code>Render</code> - <code>Diff</code></strong> 的渲染更新的主机制，奠定了最底层的基础。在下一篇文章中，我们将继续基于此完成 <strong>组件化(<code>Component</code>)<strong>、</strong>组件更新(<code>setState</code>)</strong> 以及 <strong>生命周期</strong>。希望能帮助大家更了解 React，掌握一些优秀的编程思维。</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2018/06/05/Git%E4%BF%AE%E6%94%B9gitignore%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Git修改gitignore后不起作用解决方案<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/2018/08/22/React-%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98%E5%AE%9E%E8%B7%B5-%E4%B8%8B/">React-原理揭秘实践(下)<span class="note">较新</span></a><div class="line"></div><a id="more" href="/archives">检索全部文章</a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://basilbai.github.io/">@Basil</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.2" title="v1.5.2">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.2';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
