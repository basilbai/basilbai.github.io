<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>中高级前端秘籍(上) - Basil</title>

  
    <meta name="description" content="本秘籍为了便于记忆，快速达到应试状态，类似于复习知识大纲。知识点会尽量的精简与提炼知识脉络，并不去展开深入细节，面面俱到。有兴趣或者有疑问的童鞋可以自行谷歌下对应知识点的详细内容。😋">
<meta property="og:type" content="article">
<meta property="og:title" content="中高级前端秘籍(上)">
<meta property="og:url" content="https://basilbai.github.io/2018/10/28/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%A7%98%E7%B1%8D(%E4%B8%8A)/index.html">
<meta property="og:site_name" content="Basil">
<meta property="og:description" content="本秘籍为了便于记忆，快速达到应试状态，类似于复习知识大纲。知识点会尽量的精简与提炼知识脉络，并不去展开深入细节，面面俱到。有兴趣或者有疑问的童鞋可以自行谷歌下对应知识点的详细内容。😋">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://basilbai.github.io/images/interview/4.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/2.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/5.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/3.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/1.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/6.png">
<meta property="article:published_time" content="2018-10-28T12:31:20.000Z">
<meta property="article:modified_time" content="2022-06-18T07:11:04.407Z">
<meta property="article:author" content="Basil">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://basilbai.github.io/images/interview/4.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">Basil</div><div class="sub cap">热爱技术记录分享</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/notes/">笔记</a><a class="nav-item" href="/more/">更多</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E7%82%BC%E5%8E%9F%E5%88%99"><span class="toc-text">修炼原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BFC"><span class="toc-text">2. BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">3.层叠上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80"><span class="toc-text">4. 居中布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">5. 选择器优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8E%BB%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%BD%B1%E5%93%8D%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%88%B6%E7%BA%A7%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7"><span class="toc-text">6.去除浮动影响，防止父级高度塌陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-link-%E4%B8%8E-import-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.link 与 @import 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-CSS-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-Sass-Less-Postcss"><span class="toc-text">8. CSS 预处理器(Sass&#x2F;Less&#x2F;Postcss)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-CSS-%E5%8A%A8%E7%94%BB"><span class="toc-text">9.CSS 动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C"><span class="toc-text">经验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1. 原型 &#x2F; 构造函数 &#x2F; 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9A"><span class="toc-text">2.原型链：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-EC"><span class="toc-text">3. 执行上下文(EC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.变量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">3. 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">4.作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%97%AD%E5%8C%85"><span class="toc-text">5. 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-script-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">6. script 引入方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-text">7. 对象的拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-new-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">8. new 运算符的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-instanceof-%E5%8E%9F%E7%90%86"><span class="toc-text">9. instanceof 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="toc-text">10. 代码的复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BB%A7%E6%89%BF"><span class="toc-text">11. 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">12. 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">13. 类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">14. 模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"><span class="toc-text">15. 防抖与节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%94%B9%E5%8F%98-this"><span class="toc-text">16. 函数执行改变 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ES6-ES7"><span class="toc-text">17. ES6&#x2F;ES7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-AST"><span class="toc-text">18. AST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-babel-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-text">19. babel 编译原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-text">20. 函数柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%95%B0%E7%BB%84-array"><span class="toc-text">21. 数组(array)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF"><span class="toc-text">1. 跨标签页通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-text">2. 浏览器架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop"><span class="toc-text">3. 浏览器下事件循环(Event Loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">4. 从输入 url 到展示的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81"><span class="toc-text">5. 重绘与回流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">最佳实践:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%98%E5%82%A8"><span class="toc-text">6. 存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Web-Worker"><span class="toc-text">7. Web Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-V8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">8. V8 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">9. 内存泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E7%BD%91%E7%BB%9C"><span class="toc-text">服务端与网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-http-https-%E5%8D%8F%E8%AE%AE"><span class="toc-text">1. http&#x2F;https 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">2. 常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-get-post"><span class="toc-text">3. get &#x2F; post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Websocket"><span class="toc-text">4. Websocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">5. TCP 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">6. TCP 四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Node-%E7%9A%84-Event-Loop-6-%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">7. Node 的 Event Loop: 6 个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-text">安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%EF%BC%9AVue"><span class="toc-text">框架：Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-nextTick"><span class="toc-text">1. nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2. 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81"><span class="toc-text">3. 数据响应(数据劫持)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-virtual-dom-%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">4. virtual dom 原理实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Proxy-%E7%9B%B8%E6%AF%94%E4%BA%8E-defineProperty-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">5. Proxy 相比于 defineProperty 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-vue-router"><span class="toc-text">6. vue-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-vuex"><span class="toc-text">7. vuex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%94%E5%A4%A7%E7%AE%97%E6%B3%95"><span class="toc-text">1. 五大算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">2. 基础排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">3. 高级排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%92%E5%BD%92%E8%BF%90%E7%94%A8-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%EF%BC%9A-%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98"><span class="toc-text">4. 递归运用(斐波那契数列)： 爬楼梯问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E6%A0%91"><span class="toc-text">5. 数据树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A4%A9%E5%B9%B3%E6%89%BE%E6%AC%A1%E5%93%81"><span class="toc-text">6. 天平找次品</span></a></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Basil</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%BB%8F%E9%AA%8C%E7%A7%98%E7%B1%8D/">经验秘籍</a></div><div id="post-meta">发布于&nbsp;<time datetime="2018-10-28T12:31:20.000Z">2018-10-28</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>中高级前端秘籍(上)</span></h1>
<p>本秘籍为了便于记忆，快速达到应试状态，类似于复习知识大纲。知识点会尽量的精简与提炼知识脉络，并不去展开深入细节，面面俱到。有兴趣或者有疑问的童鞋可以自行谷歌下对应知识点的详细内容。😋</p>
<span id="more"></span>

<h2 id="修炼原则"><a href="#修炼原则" class="headerlink" title="修炼原则"></a>修炼原则</h2><p>想必大家很厌烦笔试和考察知识点。因为其实在平时实战中，讲究的是开发效率，很少会去刻意记下一些细节和深挖知识点，脑海中都是一些分散的知识点，无法系统性地关联成网，一直处于似曾相识的状态。不知道多少人和博主一样，至今每次写阻止冒泡都需要谷歌一番如何拼写。🤪。</p>
<p>以如此的状态，定然是无法在面试的战场上纵横的。其实面试就犹如考试，大家回想下高考之前所做的事，无非就是 <strong>理解</strong> 和 <strong>系统性关联记忆</strong>。本秘籍的知识点较多，花点时间一个个理解并记忆后，自然也就融会贯通，无所畏惧。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h3><p>页面渲染时，dom 元素所采用的 <strong>布局模型</strong>。可通过<code>box-sizing</code>进行设置。根据计算宽高的区域可分为：</p>
<ul>
<li><code>content-box</code> (W3C 标准盒模型)</li>
<li><code>border-box</code> (IE 盒模型)</li>
<li><code>padding-box</code></li>
<li><code>margin-box</code> (浏览器未实现)</li>
</ul>
<h3 id="2-BFC"><a href="#2-BFC" class="headerlink" title="2. BFC"></a>2. BFC</h3><p><strong>块级格式化上下文</strong>，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
<blockquote>
<p>IE 下为 Layout，可通过 zoom:1 触发</p>
</blockquote>
<ul>
<li><p>触发条件:</p>
<ul>
<li>根元素</li>
<li><code>position: absolute/fixed</code></li>
<li><code>display: inline-block / table</code></li>
<li><code>float</code> 元素</li>
<li><code>ovevflow</code> !== <code>visible</code></li>
</ul>
</li>
<li><p>规则:</p>
<ul>
<li>属于同一个 BFC 的两个相邻 Box 垂直排列</li>
<li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>
<li>BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)</li>
<li>BFC 的区域不会与 float 的元素区域重叠</li>
<li>计算 BFC 的高度时，浮动子元素也参与计算</li>
<li>文字层不会被浮动层覆盖，环绕于周围</li>
</ul>
</li>
<li><p>应用:</p>
<ul>
<li>阻止<code>margin</code>重叠</li>
<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 BFC 区域之中)</li>
<li>自适应两栏布局</li>
<li>可以阻止元素被浮动元素覆盖</li>
</ul>
</li>
</ul>
<h3 id="3-层叠上下文"><a href="#3-层叠上下文" class="headerlink" title="3.层叠上下文"></a>3.层叠上下文</h3><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z 轴)</strong> 高出普通元素一等。</p>
<ul>
<li><p>触发条件</p>
<ul>
<li>根层叠上下文(<code>html</code>)</li>
<li><code>position</code></li>
<li>css3 属性<ul>
<li><code>flex</code></li>
<li><code>transform</code></li>
<li><code>opacity</code></li>
<li><code>filter</code></li>
<li><code>will-change</code></li>
<li><code>-webkit-overflow-scrolling</code></li>
</ul>
</li>
</ul>
</li>
<li><p>层叠等级：层叠上下文在 z 轴上的排序</p>
<ul>
<li>在同一层叠上下文中，层叠等级才有意义</li>
<li><code>z-index</code>的优先级最高</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/4.png"></p>
<h3 id="4-居中布局"><a href="#4-居中布局" class="headerlink" title="4. 居中布局"></a>4. 居中布局</h3><ul>
<li>水平居中<ul>
<li>行内元素: <code>text-align: center</code></li>
<li>块级元素: <code>margin: 0 auto</code></li>
<li><code>absolute + transform</code></li>
<li><code>flex + justify-content: center</code></li>
</ul>
</li>
<li>垂直居中<ul>
<li><code>line-height: height</code></li>
<li><code>absolute + transform</code></li>
<li><code>flex + align-items: center</code></li>
<li><code>table</code></li>
</ul>
</li>
<li>水平垂直居中<ul>
<li><code>absolute + transform</code></li>
<li><code>flex + justify-content + align-items</code></li>
</ul>
</li>
</ul>
<h3 id="5-选择器优先级"><a href="#5-选择器优先级" class="headerlink" title="5. 选择器优先级"></a>5. 选择器优先级</h3><ul>
<li><code>!important</code> &gt; 行内样式 &gt; <code>#id</code> &gt; <code>.class</code> &gt; <code>tag</code> &gt; * &gt; 继承 &gt; 默认</li>
<li>选择器 <strong>从右往左</strong> 解析</li>
</ul>
<h3 id="6-去除浮动影响，防止父级高度塌陷"><a href="#6-去除浮动影响，防止父级高度塌陷" class="headerlink" title="6.去除浮动影响，防止父级高度塌陷"></a>6.去除浮动影响，防止父级高度塌陷</h3><ul>
<li>通过增加尾元素清除浮动<ul>
<li><code>:after / &lt;br&gt; : clear: both</code></li>
</ul>
</li>
<li>创建父级 BFC</li>
<li>父级设置高度</li>
</ul>
<h3 id="7-link-与-import-的区别"><a href="#7-link-与-import-的区别" class="headerlink" title="7.link 与 @import 的区别"></a>7.link 与 @import 的区别</h3><ul>
<li><code>link</code>功能较多，可以定义 RSS，定义 Rel 等作用，而<code>@import</code>只能用于加载 css</li>
<li>当解析到<code>link</code>时，页面会同步加载所引的 css，而<code>@import</code>所引用的 css 会等到页面加载完才被加载</li>
<li><code>@import</code>需要 IE5 以上才能使用</li>
<li><code>link</code>可以使用 js 动态引入，<code>@import</code>不行</li>
</ul>
<h3 id="8-CSS-预处理器-Sass-Less-Postcss"><a href="#8-CSS-预处理器-Sass-Less-Postcss" class="headerlink" title="8. CSS 预处理器(Sass/Less/Postcss)"></a>8. CSS 预处理器(Sass/Less/Postcss)</h3><p>CSS 预处理器的原理: 是将类 CSS 语言通过 <strong>Webpack 编译</strong> 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:</p>
<ul>
<li>嵌套</li>
<li>变量</li>
<li>循环语句</li>
<li>条件语句</li>
<li>自动前缀</li>
<li>单位转换</li>
<li>mixin 复用</li>
</ul>
<p>面试中一般不会重点考察该点，一般介绍下自己在实战项目中的经验即可~</p>
<h3 id="9-CSS-动画"><a href="#9-CSS-动画" class="headerlink" title="9.CSS 动画"></a>9.CSS 动画</h3><ul>
<li><p><code>transition</code>: 过渡动画</p>
<ul>
<li><code>transition-property</code>: 属性</li>
<li><code>transition-duration</code>: 间隔</li>
<li><code>transition-timing-function</code>: 曲线</li>
<li><code>transition-delay</code>: 延迟</li>
<li>常用钩子: <code>transitionend</code></li>
</ul>
</li>
<li><p><code>animation / keyframes</code></p>
<ul>
<li><code>animation-name</code>: 动画名称，对应<code>@keyframes</code></li>
<li><code>animation-duration</code>: 间隔</li>
<li><code>animation-timing-function</code>: 曲线</li>
<li><code>animation-delay</code>: 延迟</li>
<li><code>animation-iteration-count</code>: 次数<ul>
<li><code>infinite</code>: 循环动画</li>
</ul>
</li>
<li><code>animation-direction</code>: 方向<ul>
<li><code>alternate</code>: 反向播放</li>
</ul>
</li>
<li><code>animation-fill-mode</code>: 静止模式<ul>
<li><code>forwards</code>: 停止时，保留最后一帧</li>
<li><code>backwards</code>: 停止时，回到第一帧</li>
<li><code>both</code>: 同时运用 <code>forwards / backwards</code></li>
</ul>
</li>
<li>常用钩子: <code>animationend</code></li>
</ul>
</li>
<li><p>动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现</p>
<ul>
<li><code>translate</code></li>
<li><code>scale</code></li>
<li><code>rotate</code></li>
<li><code>skew</code></li>
<li><code>opacity</code></li>
<li><code>color</code></li>
</ul>
</li>
</ul>
<h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>通常，CSS 并不是重点的考察领域，但这其实是由于现在国内业界对 CSS 的专注不够导致的，真正精通并专注于 CSS 的团队和人才并不多。因此如果能在 CSS 领域有自己的见解和经验，反而会为相当的加分和脱颖而出。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="1-原型-构造函数-实例"><a href="#1-原型-构造函数-实例" class="headerlink" title="1. 原型 / 构造函数 / 实例"></a>1. 原型 / 构造函数 / 实例</h3><ul>
<li><p>原型<code>(prototype)</code>: 一个简单的对象，用于实现对象的 <strong>属性继承</strong>。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code> (非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</p>
</li>
<li><p>构造函数: 可以通过<code>new</code>来 <strong>新建一个对象</strong> 的函数。</p>
</li>
<li><p>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 <strong>实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数</strong>。</p>
</li>
</ul>
<p>说了一大堆，大家可能有点懵逼，这里来举个栗子，以<code>Object</code>为例，我们常用的<code>Object</code>便是一个构造函数，因此我们可以通过它构建实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>则此时， <strong>实例为<code>instance</code></strong>, **构造函数为<code>Object</code>**，我们知道，构造函数拥有一个<code>prototype</code>的属性指向原型，因此原型为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype;</span><br></pre></td></tr></table></figure>

<p>这里我们可以来看出三者的关系:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实例.__proto__ === 原型;</span><br><span class="line"></span><br><span class="line">原型.constructor === 构造函数;</span><br><span class="line"></span><br><span class="line">构造函数.prototype === 原型;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="comment">// const o = new Object()</span></span><br><span class="line"><span class="comment">// o.constructor === Object   --&gt; true</span></span><br><span class="line"><span class="comment">// o.__proto__ = null;</span></span><br><span class="line"><span class="comment">// o.constructor === Object   --&gt; false</span></span><br><span class="line">实例.constructor === 构造函数;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处感谢 caihaihong 童鞋的指出。</p>
</blockquote>
<p>放大来看，我画了张图供大家彻底理解:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/2.png"></p>
<h3 id="2-原型链："><a href="#2-原型链：" class="headerlink" title="2.原型链："></a>2.原型链：</h3><p><strong>原型链是由原型对象组成</strong>，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链。是一个用来<strong>实现继承和共享属性</strong>的有限的对象链。</p>
<ul>
<li><p><strong>属性查找机制</strong>: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</p>
</li>
<li><p><strong>属性修改机制</strong>: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</p>
</li>
</ul>
<h3 id="3-执行上下文-EC"><a href="#3-执行上下文-EC" class="headerlink" title="3. 执行上下文(EC)"></a>3. 执行上下文(EC)</h3><p>执行上下文可以简单理解为一个对象:</p>
<ul>
<li>它包含三个部分:<ul>
<li>变量对象(VO)</li>
<li>作用域链(词法作用域)</li>
<li><code>this</code>指向</li>
</ul>
</li>
<li>它的类型:<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code>执行上下文</li>
</ul>
</li>
<li>代码执行过程:<ul>
<li>创建 <strong>全局上下文</strong> (global EC)</li>
<li>全局执行上下文 (caller) 逐行 <strong>自上而下</strong> 执行。遇到函数时，<strong>函数执行上下文</strong> (callee) 被<code>push</code>到执行栈顶层</li>
<li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li>
<li>函数执行完后，callee 被<code>pop</code>移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li>
</ul>
</li>
</ul>
<h3 id="2-变量对象"><a href="#2-变量对象" class="headerlink" title="2.变量对象"></a>2.变量对象</h3><p>变量对象，是执行上下文中的一部分，可以抽象为一种 <strong>数据作用域</strong>，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 **变量和函数声明(不包含函数表达式)**。</p>
<blockquote>
<p>活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。</p>
</blockquote>
<h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h3><p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 <strong>变量和声明的作用范围</strong>。可分为 <strong>块级作用域</strong> 和 <strong>函数作用域</strong></p>
<p>特性:</p>
<ul>
<li><strong>声明提前</strong>: 一个声明在函数体内都是可见的, 函数优先于变量</li>
<li>非匿名自执行函数，函数变量为 <strong>只读</strong> 状态，无法修改</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)(</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>; <span class="comment">// 由于foo在函数中只为可读，因此赋值无效</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125;)()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果打印：  ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h3><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 <strong>父级和自身的变量对象</strong>，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p>
<ul>
<li>由两部分组成:<ul>
<li><code>[[scope]]</code>属性: 指向父级变量对象和作用域链，也就是包含了父级的<code>[[scope]]</code>和<code>AO</code></li>
<li>AO: 自身活动对象</li>
</ul>
</li>
</ul>
<p>如此 <code>[[scopr]]</code>包含<code>[[scope]]</code>，便自上而下形成一条 <strong>链式作用域</strong>。</p>
<h3 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h3><p>闭包属于一种特殊的作用域，称为 <strong>静态作用域</strong>。它的定义可以理解为: <strong>父函数被销毁</strong> 的情况下，返回出的子函数的<code>[[scope]]</code>中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p>
<ul>
<li>闭包会产生一个很经典的问题:<ul>
<li>多个子函数的<code>[[scope]]</code>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</li>
</ul>
</li>
<li>解决:<ul>
<li>变量可以通过 <strong>函数参数的形式</strong> 传入，避免使用默认的<code>[[scope]]</code>向上查找</li>
<li>使用<code>setTimeout</code>包裹，通过第三个参数传入</li>
<li>使用 <strong>块级作用域</strong>，让变量成为自己上下文的属性，避免共享</li>
</ul>
</li>
</ul>
<h3 id="6-script-引入方式："><a href="#6-script-引入方式：" class="headerlink" title="6. script 引入方式："></a>6. script 引入方式：</h3><ul>
<li>html 静态<code>&lt;script&gt;</code>引入</li>
<li>js 动态插入<code>&lt;script&gt;</code></li>
<li><code>&lt;script defer&gt;</code>: 异步加载，元素解析完成后执行</li>
<li><code>&lt;script async&gt;</code>: 异步加载，但执行时会阻塞元素渲染</li>
</ul>
<h3 id="7-对象的拷贝"><a href="#7-对象的拷贝" class="headerlink" title="7. 对象的拷贝"></a>7. 对象的拷贝</h3><ul>
<li>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，<strong>修改时原对象也会受到影响</strong><ul>
<li><code>Object.assign</code></li>
<li>展开运算符(…)</li>
</ul>
</li>
<li>深拷贝: 完全拷贝一个新对象，<strong>修改时原对象不再受到任何影响</strong><ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>: 性能最快<ul>
<li>具有循环引用的对象时，报错</li>
<li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li>
</ul>
</li>
<li>递归进行逐一赋值</li>
</ul>
</li>
</ul>
<h3 id="8-new-运算符的执行过程"><a href="#8-new-运算符的执行过程" class="headerlink" title="8. new 运算符的执行过程"></a>8. new 运算符的执行过程</h3><ul>
<li>新生成一个对象</li>
<li>链接到原型: <code>obj.__proto__ = Con.prototype</code></li>
<li>绑定 this: <code>apply</code></li>
<li>返回新对象(如果构造函数有自己 retrun 时，则返回该值)</li>
</ul>
<h3 id="9-instanceof-原理"><a href="#9-instanceof-原理" class="headerlink" title="9. instanceof 原理"></a>9. instanceof 原理</h3><p>能在实例的 <strong>原型对象链</strong> 中找到该构造函数的<code>prototype</code>属性所指向的 <strong>原型对象</strong>，就返回<code>true</code>。即:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __proto__: 代表原型对象链</span></span><br><span class="line">instance.[__proto__...] === instance.constructor.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// return true</span></span><br></pre></td></tr></table></figure>

<h3 id="10-代码的复用"><a href="#10-代码的复用" class="headerlink" title="10. 代码的复用"></a>10. 代码的复用</h3><p>当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:</p>
<ul>
<li>函数封装</li>
<li>继承</li>
<li>复制<code>extend</code></li>
<li>混入<code>mixin</code></li>
<li>借用<code>apply/call</code></li>
</ul>
<h3 id="11-继承"><a href="#11-继承" class="headerlink" title="11. 继承"></a>11. 继承</h3><p>在 JS 中，继承通常指的便是 <strong>原型链继承</strong>，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p>
<ul>
<li>最优化: <strong>圣杯模式</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params">c, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c, p</span>) </span>&#123;</span><br><span class="line">    F.prototype = p.prototype;</span><br><span class="line">    c.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    c.uber = p.prototype;</span><br><span class="line">    c.prototype.constructor = c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 ES6 的语法糖 <code>class / extends</code></li>
</ul>
<h3 id="12-类型转换"><a href="#12-类型转换" class="headerlink" title="12. 类型转换"></a>12. 类型转换</h3><p>大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p>
<ul>
<li>-、*、/、% ：一律转换成数值后计算</li>
<li>+：<ul>
<li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li>
<li>数字 + 对象， 优先调用对象的<code>valueOf</code> -&gt; <code>toString</code></li>
<li>数字 + <code>boolean/null</code> -&gt; 数字</li>
<li>数字 + <code>undefined</code> -&gt; <code>NaN</code></li>
</ul>
</li>
<li><code>[1].toString() === &#39;1&#39;</code></li>
<li><code>&#123;&#125;.toString() === &#39;[object object]&#39;</code></li>
<li><code>NaN</code> !== <code>NaN</code> 、<code>+undefined 为 NaN</code></li>
</ul>
<h3 id="13-类型判断"><a href="#13-类型判断" class="headerlink" title="13. 类型判断"></a>13. 类型判断</h3><p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p>
<ul>
<li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li>
<li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: 直接使用 <code>typeof</code>即可</li>
<li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li>
</ul>
<p>很稳的判断封装:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> class2type = &#123;&#125;;</span><br><span class="line"><span class="string">&quot;Array Date RegExp Object Error&quot;</span></span><br><span class="line">  .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">  .forEach(<span class="function">(<span class="params">e</span>) =&gt;</span> (class2type[<span class="string">&quot;[object &quot;</span> + e + <span class="string">&quot;]&quot;</span>] = e.toLowerCase()));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span></span><br><span class="line">    ? class2type[<span class="built_in">Object</span>.prototype.toString.call(obj)] || <span class="string">&quot;object&quot;</span></span><br><span class="line">    : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-模块化"><a href="#14-模块化" class="headerlink" title="14. 模块化"></a>14. 模块化</h3><p>模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 <strong>在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。</strong></p>
<ul>
<li><p>分类:</p>
<ul>
<li>es6: <code>import / export</code></li>
<li>commonjs: <code>require / module.exports / exports</code></li>
<li>amd: <code>require / defined</code></li>
</ul>
</li>
<li><p><code>require</code>与<code>import</code>的区别</p>
<ul>
<li><code>require</code>支持 <strong>动态导入</strong>，<code>import</code>不支持，正在提案 (babel 下可支持)</li>
<li><code>require</code>是 <strong>同步</strong> 导入，<code>import</code>属于 <strong>异步</strong> 导入</li>
<li><code>require</code>是 <strong>值拷贝</strong>，导出值变化不会影响导入值；<code>import</code>指向 <strong>内存地址</strong>，导入值会随导出值而变化</li>
</ul>
</li>
</ul>
<h3 id="15-防抖与节流"><a href="#15-防抖与节流" class="headerlink" title="15. 防抖与节流"></a>15. 防抖与节流</h3><p>防抖与节流函数是一种最常用的 <strong>高频触发优化方式</strong>，能对性能有较大的帮助。</p>
<ul>
<li><strong>防抖 (debounce)</strong>: 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>节流(throttle)</strong>: 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms 执行一次即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> callNow = immediate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      callNow = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-函数执行改变-this"><a href="#16-函数执行改变-this" class="headerlink" title="16. 函数执行改变 this"></a>16. 函数执行改变 this</h3><p>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code>。</p>
<p>因此要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如:</p>
<ul>
<li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li>
<li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li>
</ul>
<p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p>
<ul>
<li><code>call: fn.call(target, 1, 2)</code></li>
<li><code>apply: fn.apply(target, [1, 2])</code></li>
<li><code>bind: fn.bind(target)(1,2)</code></li>
</ul>
<h3 id="17-ES6-ES7"><a href="#17-ES6-ES7" class="headerlink" title="17. ES6/ES7"></a>17. ES6/ES7</h3><p>由于 Babel 的强大和普及，现在 ES6/ES7 基本上已经是现代化开发的必备了。通过新的语法糖，能让代码整体更为简洁和易读。</p>
<ul>
<li><p>声明</p>
<ul>
<li><code>let / const</code>: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明</li>
<li><code>const</code>: 声明常量，无法修改</li>
</ul>
</li>
<li><p>解构赋值</p>
</li>
<li><p><code>class / extend</code>: 类声明与继承</p>
</li>
<li><p><code>Set / Map</code>: 新的数据结构</p>
</li>
<li><p>异步解决方案:</p>
<ul>
<li><p><code>Promise</code>的使用与实现</p>
</li>
<li><p><code>generator</code>:</p>
<ul>
<li><code>yield</code>: 暂停代码</li>
<li><code>next()</code>: 继续执行代码</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = helloWorld();</span><br><span class="line"></span><br><span class="line">generator.next(); <span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next(); <span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next(); <span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>await / async</code>: 是<code>generator</code>的语法糖， babel 中是基于<code>promise</code>实现。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserByAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> getUserByAsync();</span><br><span class="line"><span class="built_in">console</span>.log(user);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-AST"><a href="#18-AST" class="headerlink" title="18. AST"></a>18. AST</h3><p>**抽象语法树 (Abstract Syntax Tree)**，是将代码逐字母解析成 <strong>树状对象</strong> 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过解析转化成的<code>AST</code>如下图:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/5.png"></p>
<h3 id="19-babel-编译原理"><a href="#19-babel-编译原理" class="headerlink" title="19. babel 编译原理"></a>19. babel 编译原理</h3><ul>
<li>babylon 将 ES6/ES7 代码解析成 AST</li>
<li>babel-traverse 对 AST 进行遍历转译，得到新的 AST</li>
<li>新 AST 通过 babel-generator 转换成 ES5</li>
</ul>
<h3 id="20-函数柯里化"><a href="#20-函数柯里化" class="headerlink" title="20. 函数柯里化"></a>20. 函数柯里化</h3><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 <strong>预置通用参数</strong>，供多次重复调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add1 = add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>) === <span class="number">3</span>;</span><br><span class="line">add1(<span class="number">20</span>) === <span class="number">21</span>;</span><br></pre></td></tr></table></figure>

<h3 id="21-数组-array"><a href="#21-数组-array" class="headerlink" title="21. 数组(array)"></a>21. 数组(array)</h3><ul>
<li><p><code>map</code>: 遍历数组，返回回调返回值组成的新数组</p>
</li>
<li><p><code>forEach</code>: 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</p>
</li>
<li><p><code>filter</code>: 过滤</p>
</li>
<li><p><code>some</code>: 有一项返回<code>true</code>，则整体为<code>true</code></p>
</li>
<li><p><code>every</code>: 有一项返回<code>false</code>，则整体为<code>false</code></p>
</li>
<li><p><code>join</code>: 通过指定连接符生成字符串</p>
</li>
<li><p><code>push / pop</code>: 末尾推入和弹出，改变原数组， 返回推入/弹出项</p>
</li>
<li><p><code>unshift / shift</code>: 头部推入和弹出，改变原数组，返回操作项</p>
</li>
<li><p><code>sort(fn) / reverse</code>: 排序与反转，改变原数组</p>
</li>
<li><p><code>concat</code>: 连接数组，不影响原数组， 浅拷贝</p>
</li>
<li><p><code>slice(start, end)</code>: 返回截断后的新数组，不改变原数组</p>
</li>
<li><p><code>splice(start, number, value...)</code>: 返回删除元素组成的数组，value 为插入项，改变原数组</p>
</li>
<li><p><code>indexOf / lastIndexOf(value, fromIndex)</code>: 查找数组项，返回对应的下标</p>
</li>
<li><p><code>reduce / reduceRight(fn(prev, cur)， defaultPrev)</code>: 两两执行，prev 为上次化简函数的<code>return</code>值，cur 为当前值(从第二项开始)</p>
</li>
<li><p>数组乱序：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>数组拆解: flat: [1,[2,3]] –&gt; [1, 2, 3]</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.toString()</span><br><span class="line">    .split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> +item);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="1-跨标签页通讯"><a href="#1-跨标签页通讯" class="headerlink" title="1. 跨标签页通讯"></a>1. 跨标签页通讯</h3><p>不同标签页间的通讯，本质原理就是去运用一些可以 <strong>共享的中间介质</strong>，因此比较常用的有以下方法:</p>
<ul>
<li><p>通过父页面<code>window.open()</code>和子页面<code>postMessage</code></p>
<ul>
<li>异步下，通过 <code>window.open(&#39;about: blank&#39;)</code> 和 <code>tab.location.href = &#39;*&#39;</code></li>
</ul>
</li>
<li><p>设置同域下共享的<code>localStorage</code>与监听<code>window.onstorage</code></p>
<ul>
<li>重复写入相同的值无法触发</li>
<li>会受到浏览器隐身模式等的限制</li>
</ul>
</li>
<li><p>设置共享<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</p>
</li>
<li><p>借助服务端或者中间层实现</p>
</li>
</ul>
<h3 id="2-浏览器架构"><a href="#2-浏览器架构" class="headerlink" title="2. 浏览器架构"></a>2. 浏览器架构</h3><ul>
<li>用户界面</li>
<li>主进程</li>
<li>内核<ul>
<li>渲染引擎</li>
<li>JS 引擎<ul>
<li>执行栈</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>消息队列<ul>
<li>微任务</li>
<li>宏任务</li>
</ul>
</li>
</ul>
</li>
<li>网络异步线程</li>
<li>定时器线程</li>
</ul>
</li>
</ul>
<h3 id="3-浏览器下事件循环-Event-Loop"><a href="#3-浏览器下事件循环-Event-Loop" class="headerlink" title="3. 浏览器下事件循环(Event Loop)"></a>3. 浏览器下事件循环(Event Loop)</h3><p>事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表</p>
<ul>
<li>微任务 <code>microtask(jobs)</code>: <code>promise / ajax / Object.observe(该方法已废弃)</code></li>
<li>宏任务 <code>macrotask(task)</code>: <code>setTimout / script / IO / UI Rendering</code></li>
</ul>
<h3 id="4-从输入-url-到展示的过程"><a href="#4-从输入-url-到展示的过程" class="headerlink" title="4. 从输入 url 到展示的过程"></a>4. 从输入 url 到展示的过程</h3><ul>
<li>DNS 解析</li>
<li>TCP 三次握手</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>浏览器渲染<ul>
<li>HTML parser –&gt; DOM Tree<ul>
<li>标记化算法，进行元素状态的标记</li>
<li>dom 树构建</li>
</ul>
</li>
<li>CSS parser –&gt; Style Tree<ul>
<li>解析 css 代码，生成样式树</li>
</ul>
</li>
<li>attachment –&gt; Render Tree<ul>
<li>结合 dom 树 与 style 树，生成渲染树</li>
</ul>
</li>
<li>layout: 布局</li>
<li>GPU painting: 像素绘制页面</li>
</ul>
</li>
</ul>
<h3 id="5-重绘与回流"><a href="#5-重绘与回流" class="headerlink" title="5. 重绘与回流"></a>5. 重绘与回流</h3><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p>
<ul>
<li><p><strong>重绘(repaint)</strong>: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此 <strong>损耗较少</strong></p>
</li>
<li><p><strong>回流(reflow)</strong>: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</p>
<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 dom 元素</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</strong></p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践:"></a>最佳实践:</h4><ul>
<li><p>css</p>
<ul>
<li>避免使用<code>table</code>布局</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li>
</ul>
</li>
<li><p>javascript</p>
<ul>
<li>避免频繁操作样式，可汇总后统一 <strong>一次修改</strong></li>
<li>尽量使用<code>class</code>进行样式修改</li>
<li>减少<code>dom</code>的增删次数，可使用 <strong>字符串</strong> 或者 <code>documentFragment</code> 一次性插入</li>
<li>极限优化时，修改样式可将其<code>display: none</code>后修改</li>
<li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 <strong>变量存住</strong></li>
</ul>
</li>
</ul>
<h3 id="6-存储"><a href="#6-存储" class="headerlink" title="6. 存储"></a>6. 存储</h3><p>我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</p>
<ul>
<li><p>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</p>
</li>
<li><p>持久性存储，可以分为 浏览器端 与 服务器端</p>
<ul>
<li>浏览器:<ul>
<li><code>cookie</code>: 通常用于存储用户身份，登录状态等<ul>
<li>http 中自动携带， 体积上限为 4K， 可自行设置过期时间</li>
</ul>
</li>
<li><code>localStorage / sessionStorage</code>: 长久储存/窗口关闭删除， 体积限制为 4~5M</li>
<li><code>indexDB</code></li>
</ul>
</li>
<li>服务器:<ul>
<li>分布式缓存 redis</li>
<li>数据库</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-Web-Worker"><a href="#7-Web-Worker" class="headerlink" title="7. Web Worker"></a>7. Web Worker</h3><p>现代浏览器为<code>JavaScript</code>创造的 <strong>多线程环境</strong>。可以新建并将部分任务分配到<code>worker</code>线程并行运行，两个线程可 <strong>独立运行，互不干扰</strong>，可通过自带的 <strong>消息机制</strong> 相互通信。</p>
<p><strong>基本用法:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">&quot;work.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向主进程推送消息</span></span><br><span class="line">worker.postMessage(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听主进程来的消息</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Received message &quot;</span> + event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>限制:</strong></p>
<ul>
<li>同源限制</li>
<li>无法使用 <code>document</code> / <code>window</code> / <code>alert</code> / <code>confirm</code></li>
<li>无法加载本地资源</li>
</ul>
<h3 id="8-V8-垃圾回收机制"><a href="#8-V8-垃圾回收机制" class="headerlink" title="8. V8 垃圾回收机制"></a>8. V8 垃圾回收机制</h3><p>垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 <strong>新生代空间</strong> 和 <strong>老生代空间</strong>。</p>
<ul>
<li><strong>新生代空间</strong>: 用于存活较短的对象<ul>
<li>又分成两个空间: from 空间 与 to 空间</li>
<li>Scavenge GC 算法: 当 from 空间被占满时，启动 GC 算法<ul>
<li>存活的对象从 from space 转移到 to space</li>
<li>清空 from space</li>
<li>from space 与 to space 互换</li>
<li>完成一次新生代 GC</li>
</ul>
</li>
</ul>
</li>
<li><strong>老生代空间</strong>: 用于存活时间较长的对象<ul>
<li>从 新生代空间 转移到 老生代空间 的条件<ul>
<li>经历过一次以上 Scavenge GC 的对象</li>
<li>当 to space 体积超过 25%</li>
</ul>
</li>
<li><strong>标记清除算法</strong>: 标记存活的对象，未被标记的则被释放<ul>
<li>增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能</li>
<li>并发标记(最新技术): 不阻塞 js 执行</li>
</ul>
</li>
<li><strong>压缩算法</strong>: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 <strong>内存的碎片化</strong></li>
</ul>
</li>
</ul>
<h3 id="9-内存泄露"><a href="#9-内存泄露" class="headerlink" title="9. 内存泄露"></a>9. 内存泄露</h3><ul>
<li>意外的<strong>全局变量</strong>: 无法被回收</li>
<li><strong>定时器</strong>: 未被正确关闭，导致所引用的外部变量无法被释放</li>
<li><strong>事件监听</strong>: 没有正确销毁 (低版本浏览器可能出现)</li>
<li><strong>闭包</strong>: 会导致父级中的变量无法被释放</li>
<li><strong>dom 引用</strong>: dom 元素被删除时，内存中的引用未被正确清空</li>
</ul>
<p>可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。</p>
<h2 id="服务端与网络"><a href="#服务端与网络" class="headerlink" title="服务端与网络"></a>服务端与网络</h2><h3 id="1-http-https-协议"><a href="#1-http-https-协议" class="headerlink" title="1. http/https 协议"></a>1. http/https 协议</h3><ul>
<li><p>1.0 协议缺陷:</p>
<ul>
<li>无法复用链接，完成即断开，<strong>重新慢启动和 TCP 3 次握手</strong></li>
<li>head of line blocking: <strong>线头阻塞</strong>，导致请求之间互相影响</li>
</ul>
</li>
<li><p>1.1 改进:</p>
<ul>
<li><strong>长连接</strong>(默认 keep-alive)，复用</li>
<li>host 字段指定对应的虚拟站点</li>
<li>新增功能:<ul>
<li>断点续传</li>
<li>身份认证</li>
<li>状态管理</li>
<li>cache 缓存<ul>
<li>Cache-Control</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Etag</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.0:</p>
<ul>
<li>多路复用</li>
<li>二进制分帧层: 应用层和传输层之间</li>
<li>首部压缩</li>
<li>服务端推送</li>
</ul>
</li>
<li><p>https: 较为安全的网络传输协议</p>
<ul>
<li>证书(公钥)</li>
<li>SSL 加密</li>
<li>端口 443</li>
</ul>
</li>
<li><p>TCP:</p>
<ul>
<li>三次握手</li>
<li>四次挥手</li>
<li>滑动窗口: 流量控制</li>
<li>拥塞处理<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存策略: 可分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong></p>
<ul>
<li>Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，<strong>Cache-Control 的 max-age 优先级高于 Expires</strong></li>
<li>当缓存已经过期时，使用协商缓存<ul>
<li>唯一标识方案: Etag(response 携带) &amp; If-None-Match(request 携带，上一次返回的 Etag): 服务器判断资源是否被修改，</li>
<li>最后一次修改时间: Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的 Last-Modified)<ul>
<li>如果一致，则直接返回 304 通知浏览器使用缓存</li>
<li>如不一致，则服务端返回新的资源</li>
</ul>
</li>
</ul>
</li>
<li>Last-Modified 缺点：<ul>
<li>周期性修改，但内容未变时，会导致缓存失效</li>
<li>最小粒度只到 s， s 以内的改动无法检测到</li>
</ul>
</li>
<li>Etag 的优先级高于 Last-Modified</li>
</ul>
</li>
</ul>
<h3 id="2-常见状态码"><a href="#2-常见状态码" class="headerlink" title="2. 常见状态码"></a>2. 常见状态码</h3><ul>
<li>1xx: 接受，继续处理</li>
<li>200: 成功，并返回数据</li>
<li>201: 已创建</li>
<li>202: 已接受</li>
<li>203: 成为，但未授权</li>
<li>204: 成功，无内容</li>
<li>205: 成功，重置内容</li>
<li>206: 成功，部分内容</li>
<li>301: 永久移动，重定向</li>
<li>302: 临时移动，可使用原有 URI</li>
<li>304: 资源未修改，可使用缓存</li>
<li>305: 需代理访问</li>
<li>400: 请求语法错误</li>
<li>401: 要求身份认证</li>
<li>403: 拒绝请求</li>
<li>404: 资源不存在</li>
<li>500: 服务器错误</li>
</ul>
<h3 id="3-get-post"><a href="#3-get-post" class="headerlink" title="3. get / post"></a>3. get / post</h3><ul>
<li>get: 缓存、请求长度受限、会被历史保存记录<ul>
<li>无副作用(不修改资源)，幂等(请求次数与资源无关)的场景</li>
</ul>
</li>
<li>post: 安全、大数据、更多编码类型</li>
</ul>
<p>两者详细对比如下图:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/3.png"></p>
<h3 id="4-Websocket"><a href="#4-Websocket" class="headerlink" title="4. Websocket"></a>4. Websocket</h3><p>Websocket 是一个 <strong>持久化的协议</strong>， 基于 http ， 服务端可以 <strong>主动 push</strong></p>
<ul>
<li><p>兼容：</p>
<ul>
<li>FLASH Socket</li>
<li>长轮询： 定时发送 ajax</li>
<li>long poll： 发送 –&gt; 有消息时再 response</li>
</ul>
</li>
<li><p><code>new WebSocket(url)</code></p>
</li>
<li><p><code>ws.onerror = fn</code></p>
</li>
<li><p><code>ws.onclose = fn</code></p>
</li>
<li><p><code>ws.onopen = fn</code></p>
</li>
<li><p><code>ws.onmessage = fn</code></p>
</li>
<li><p><code>ws.send()</code></p>
</li>
</ul>
<h3 id="5-TCP-三次握手"><a href="#5-TCP-三次握手" class="headerlink" title="5. TCP 三次握手"></a>5. TCP 三次握手</h3><p>建立连接前，客户端和服务端需要通过握手来确认对方:</p>
<ul>
<li>客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认</li>
<li>服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态</li>
<li>客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态</li>
</ul>
<h3 id="6-TCP-四次挥手"><a href="#6-TCP-四次挥手" class="headerlink" title="6. TCP 四次挥手"></a>6. TCP 四次挥手</h3><ul>
<li>客户端 – FIN –&gt; 服务端， FIN—WAIT</li>
<li>服务端 – ACK –&gt; 客户端， CLOSE-WAIT</li>
<li>服务端 – ACK,FIN –&gt; 客户端， LAST-ACK</li>
<li>客户端 – ACK –&gt; 服务端，CLOSED</li>
</ul>
<h3 id="7-Node-的-Event-Loop-6-个阶段"><a href="#7-Node-的-Event-Loop-6-个阶段" class="headerlink" title="7. Node 的 Event Loop: 6 个阶段"></a>7. Node 的 Event Loop: 6 个阶段</h3><ul>
<li>timer 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</li>
<li>I/O 阶段: 执行上轮循环残流的<code>callback</code></li>
<li>idle, prepare</li>
<li>poll: 等待回调<ul>
<li><ol>
<li> 执行回调</li>
</ol>
</li>
<li><ol start="2">
<li> 执行定时器</li>
</ol>
<ul>
<li>如有到期的<code>setTimeout / setInterval</code>， 则返回 timer 阶段</li>
<li>如有<code>setImmediate</code>，则前往 check 阶段</li>
</ul>
</li>
</ul>
</li>
<li>check<ul>
<li>执行<code>setImmediate</code></li>
</ul>
</li>
<li>close callbacks</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>JSONP: 利用<code>&lt;script&gt;</code>标签不受跨域限制的特点，缺点是只能支持 get 请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  script.src = url;</span><br><span class="line">  script.async = <span class="literal">true</span>;</span><br><span class="line">  script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 CORS: Access-Control-Allow-Origin：*</li>
<li>postMessage</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>XSS 攻击: 注入恶意代码<ul>
<li>cookie 设置 httpOnly</li>
<li>转义页面上的输入内容和输出内容</li>
</ul>
</li>
<li>CSRF: 跨站请求伪造，防护:<ul>
<li>get 不修改数据</li>
<li>不被第三方网站访问到用户的 cookie</li>
<li>设置白名单，不被第三方网站请求</li>
<li>请求校验</li>
</ul>
</li>
</ul>
<h2 id="框架：Vue"><a href="#框架：Vue" class="headerlink" title="框架：Vue"></a>框架：Vue</h2><h3 id="1-nextTick"><a href="#1-nextTick" class="headerlink" title="1. nextTick"></a>1. nextTick</h3><p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p>
<ul>
<li><p>新版本中默认是<code>mincrotasks</code>, <code>v-on</code>中会使用<code>macrotasks</code></p>
</li>
<li><p><code>macrotasks</code>任务的实现:</p>
<ul>
<li><code>setImmediate / MessageChannel / setTimeout</code></li>
</ul>
</li>
</ul>
<h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h3><ul>
<li><p><code>_init_</code></p>
<ul>
<li><code>initLifecycle/Event</code>，往<code>vm</code>上挂载各种属性</li>
<li><code>callHook: beforeCreated</code>: 实例刚创建</li>
<li><code>initInjection/initState</code>: 初始化注入和 data 响应性</li>
<li><code>created</code>: 创建完成，属性已经绑定， 但还未生成真实<code>dom</code></li>
<li>进行元素的挂载： <code>$el / vm.$mount()</code></li>
<li>是否有<code>template</code>: 解析成<code>render function</code><ul>
<li><code>*.vue</code>文件: <code>vue-loader</code>会将<code>&lt;template&gt;</code>编译成<code>render function</code></li>
</ul>
</li>
<li><code>beforeMount</code>: 模板编译/挂载之前</li>
<li>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</li>
<li><code>mounted</code>: 组件已挂载</li>
</ul>
</li>
<li><p><code>update</code>:</p>
<ul>
<li>执行<code>diff</code>算法，比对改变是否需要触发 UI 更新</li>
<li><code>flushScheduleQueue</code><ul>
<li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子 - <code>watcher.run()</code>: 执行<code>watcher</code>中的 <code>notify</code>，通知所有依赖项更新 UI</li>
</ul>
</li>
<li>触发<code>updated</code>钩子: 组件已更新</li>
</ul>
</li>
<li><p><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</p>
</li>
<li><p><code>destroy</code>:</p>
<ul>
<li><code>beforeDestroy</code>: 销毁开始</li>
<li>销毁自身且递归销毁子组件以及事件监听<ul>
<li><code>remove()</code>: 删除节点</li>
<li><code>watcher.teardown()</code>: 清空依赖</li>
<li><code>vm.$off()</code>: 解绑监听</li>
</ul>
</li>
<li><code>destroyed</code>: 完成后触发钩子</li>
</ul>
</li>
</ul>
<p>上面是<code>vue</code>的声明周期的简单梳理，接下来我们直接以代码的形式来完成<code>vue</code>的初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Vue实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 挂载属性</span></span><br><span class="line">    initLifeCycle(vm)</span><br><span class="line">    <span class="comment">// 初始化事件系统，钩子函数等</span></span><br><span class="line">    initEvent(vm)</span><br><span class="line">    <span class="comment">// 编译slot、vnode</span></span><br><span class="line">    initRender(vm)</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="comment">// 添加inject功能</span></span><br><span class="line">    initInjection(vm)</span><br><span class="line">    <span class="comment">// 完成数据响应性 props/data/watch/computed/methods</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    <span class="comment">// 添加 provide 功能</span></span><br><span class="line">    initProvide(vm)</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 挂载节点</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">        vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载节点实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 获取 render function</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.options.render) &#123;</span><br><span class="line">        <span class="comment">// template to render</span></span><br><span class="line">        <span class="comment">// Vue.compile = compileToFunctions</span></span><br><span class="line">        <span class="keyword">let</span> &#123; render &#125; = compileToFunctions()</span><br><span class="line">        <span class="built_in">this</span>.options.render = render</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(<span class="string">&#x27;beforeMounte&#x27;</span>)</span><br><span class="line">    <span class="comment">// 初始化观察者</span></span><br><span class="line">    <span class="comment">// render 渲染 vdom，</span></span><br><span class="line">    vdom = vm.render()</span><br><span class="line">    <span class="comment">// update: 根据 diff 出的 patchs 挂载成真实的 dom</span></span><br><span class="line">    vm._update(vdom)</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点实现</span></span><br><span class="line">funtion <span class="function"><span class="title">queueWatcher</span>(<span class="params">watcher</span>)</span> &#123;</span><br><span class="line">	nextTick(flushScheduleQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushScheduleQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 遍历队列中所有修改</span></span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">	    <span class="comment">// beforeUpdate</span></span><br><span class="line">        watcher.before()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖局部更新节点</span></span><br><span class="line">        watcher.update()</span><br><span class="line">        callHook(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁实例实现</span></span><br><span class="line">Vue.prototype.$destory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestory&#x27;</span>)</span><br><span class="line">    <span class="comment">// 自身及子节点</span></span><br><span class="line">    remove()</span><br><span class="line">    <span class="comment">// 删除依赖</span></span><br><span class="line">    watcher.teardown()</span><br><span class="line">    <span class="comment">// 删除监听</span></span><br><span class="line">    vm.$off()</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destoryed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-数据响应-数据劫持"><a href="#3-数据响应-数据劫持" class="headerlink" title="3. 数据响应(数据劫持)"></a>3. 数据响应(数据劫持)</h3><p>看完生命周期后，里面的<code>watcher</code>等内容其实是数据响应中的一部分。数据响应的实现由两部分构成: <strong>观察者( watcher )</strong> 和 **依赖收集器( Dep )**，其核心是 <code>defineProperty</code>这个方法，它可以 <strong>重写属性的 get 与 set</strong> 方法，从而完成监听数据的改变。</p>
<ul>
<li>Observe (观察者)观察 props 与 state<ul>
<li>遍历 props 与 state，对每个属性创建独立的监听器( watcher )</li>
</ul>
</li>
<li>使用 <code>defineProperty</code> 重写每个属性的 get/set(<code>defineReactive</code>）<ul>
<li><code>get</code>: 收集依赖<ul>
<li><code>Dep.depend()</code><ul>
<li><code>watcher.addDep()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>set</code>: 派发更新<ul>
<li><code>Dep.notify()</code></li>
<li><code>watcher.update()</code></li>
<li><code>queenWatcher()</code></li>
<li><code>nextTick</code></li>
<li><code>flushScheduleQueue</code></li>
<li><code>watcher.run()</code></li>
<li><code>updateComponent()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大家可以先看下面的数据相应的代码实现后，理解后就比较容易看懂上面的简单脉络了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 数据响应性</span></span><br><span class="line">observe(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化观察者</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">&quot;name&quot;</span>, updateComponent);</span><br><span class="line">data.a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单表示用于数据更新后的操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  vm._update(); <span class="comment">// patchs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历对象，使用 get/set 重新定义对象的每个属性值</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, k, v</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="keyword">if</span> (type(v) == <span class="string">&quot;object&quot;</span>) observe(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建依赖收集器</span></span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="comment">// 定义get/set</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, k, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.addSub(Dep.target);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 重新设置值时，触发收集器的通知机制</span></span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">nV</span>) </span>&#123;</span><br><span class="line">      v = nV;</span><br><span class="line">      dep.nofify();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.map(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj, key, cb</span>)</span> &#123;</span><br><span class="line">    Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = obj[key];</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addDep</span>(<span class="params">Dep</span>)</span> &#123;</span><br><span class="line">    Dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.obj[<span class="built_in">this</span>.key];</span><br><span class="line">    <span class="built_in">this</span>.cb(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">before</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    callHook(<span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-virtual-dom-原理实现"><a href="#4-virtual-dom-原理实现" class="headerlink" title="4. virtual dom 原理实现"></a>4. virtual dom 原理实现</h3><ul>
<li>创建 dom 树</li>
<li>树的<code>diff</code>，同层对比，输出<code>patchs(listDiff/diffChildren/diffProps)</code><ul>
<li>没有新的节点，返回</li>
<li>新的节点<code>tagName</code>与<code>key</code>不变， 对比<code>props</code>，继续递归遍历子树<ul>
<li>对比属性(对比新旧属性列表):<ul>
<li>旧属性是否存在与新属性列表中</li>
<li>都存在的是否有变化</li>
<li>是否出现旧列表中没有的新属性</li>
</ul>
</li>
</ul>
</li>
<li><code>tagName</code>和<code>key</code>值变化了，则直接替换成新节点</li>
</ul>
</li>
<li>渲染差异<ul>
<li>遍历<code>patchs</code>， 把需要更改的节点取出来</li>
<li>局部更新<code>dom</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diff算法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 差异收集</span></span><br><span class="line">  <span class="keyword">let</span> pathchs = &#123;&#125;;</span><br><span class="line">  dfs(oldTree, newTree, <span class="number">0</span>, pathchs);</span><br><span class="line">  <span class="keyword">return</span> pathchs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, pathchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curPathchs = [];</span><br><span class="line">  <span class="keyword">if</span> (newNode) &#123;</span><br><span class="line">    <span class="comment">// 当新旧节点的 tagName 和 key 值完全一致时</span></span><br><span class="line">    <span class="keyword">if</span> (oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123;</span><br><span class="line">      <span class="comment">// 继续比对属性差异</span></span><br><span class="line">      <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props);</span><br><span class="line">      curPathchs.push(&#123; <span class="attr">type</span>: <span class="string">&quot;changeProps&quot;</span>, props &#125;);</span><br><span class="line">      <span class="comment">// 递归进入下一层级的比较</span></span><br><span class="line">      diffChildrens(oldNode.children, newNode.children, index, pathchs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当 tagName 或者 key 修改了后，表示已经是全新节点，无需再比</span></span><br><span class="line">      curPathchs.push(&#123; <span class="attr">type</span>: <span class="string">&quot;replaceNode&quot;</span>, <span class="attr">node</span>: newNode &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建出整颗差异树</span></span><br><span class="line">  <span class="keyword">if</span> (curPathchs.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathchs[index]) &#123;</span><br><span class="line">      pathchs[index] = pathchs[index].concat(curPathchs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pathchs[index] = curPathchs;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性对比实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propsPathchs = [];</span><br><span class="line">  <span class="comment">// 遍历新旧属性列表</span></span><br><span class="line">  <span class="comment">// 查找删除项</span></span><br><span class="line">  <span class="comment">// 查找修改项</span></span><br><span class="line">  <span class="comment">// 查找新增项</span></span><br><span class="line">  forin(olaProps, <span class="function">(<span class="params">k, v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newProps.hasOwnProperty(k)) &#123;</span><br><span class="line">      propsPathchs.push(&#123; <span class="attr">type</span>: <span class="string">&quot;remove&quot;</span>, <span class="attr">prop</span>: k &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (v !== newProps[k]) &#123;</span><br><span class="line">        propsPathchs.push(&#123; <span class="attr">type</span>: <span class="string">&quot;change&quot;</span>, <span class="attr">prop</span>: k, <span class="attr">value</span>: newProps[k] &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  forin(newProps, <span class="function">(<span class="params">k, v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!oldProps.hasOwnProperty(k)) &#123;</span><br><span class="line">      propsPathchs.push(&#123; <span class="attr">type</span>: <span class="string">&quot;add&quot;</span>, <span class="attr">prop</span>: k, <span class="attr">value</span>: v &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> propsPathchs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比子级差异</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildrens</span>(<span class="params">oldChild, newChild, index, pathchs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 标记子级的删除/新增/移动</span></span><br><span class="line">  <span class="keyword">let</span> &#123; change, list &#125; = diffList(oldChild, newChild, index, pathchs);</span><br><span class="line">  <span class="keyword">if</span> (change.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathchs[index]) &#123;</span><br><span class="line">      pathchs[index] = pathchs[index].concat(change);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pathchs[index] = change;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 key 获取原本匹配的节点，进一步递归从头开始对比</span></span><br><span class="line">  oldChild.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keyIndex = list.indexOf(item.key);</span><br><span class="line">    <span class="keyword">if</span> (keyIndex) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = newChild[keyIndex];</span><br><span class="line">      <span class="comment">// 进一步递归对比</span></span><br><span class="line">      dfs(item, node, index, pathchs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表对比，主要也是根据 key 值查找匹配项</span></span><br><span class="line"><span class="comment">// 对比出新旧列表的新增/删除/移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffList</span>(<span class="params">oldList, newList, index, pathchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> change = [];</span><br><span class="line">  <span class="keyword">let</span> list = [];</span><br><span class="line">  <span class="keyword">const</span> newKeys = getKey(newList);</span><br><span class="line">  oldList.map(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newKeys.indexOf(v.key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      list.push(v.key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记删除</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">      list.splice(i, <span class="number">1</span>);</span><br><span class="line">      change.push(&#123; <span class="attr">type</span>: <span class="string">&quot;remove&quot;</span>, <span class="attr">index</span>: i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记新增和移动</span></span><br><span class="line">  newList.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = item.key;</span><br><span class="line">    <span class="keyword">const</span> index = list.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span> || key == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 新增</span></span><br><span class="line">      change.push(&#123; <span class="attr">type</span>: <span class="string">&quot;add&quot;</span>, <span class="attr">node</span>: item, <span class="attr">index</span>: i &#125;);</span><br><span class="line">      list.splice(i, <span class="number">0</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 移动</span></span><br><span class="line">      <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;move&quot;</span>,</span><br><span class="line">          <span class="attr">form</span>: index,</span><br><span class="line">          <span class="attr">to</span>: i,</span><br><span class="line">        &#125;);</span><br><span class="line">        move(list, index, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; change, list &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Proxy-相比于-defineProperty-的优势"><a href="#5-Proxy-相比于-defineProperty-的优势" class="headerlink" title="5. Proxy 相比于 defineProperty 的优势"></a>5. Proxy 相比于 defineProperty 的优势</h3><ul>
<li>数组变化也能监听到</li>
<li>不需要深度遍历监听</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> reactiveData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-vue-router"><a href="#6-vue-router" class="headerlink" title="6. vue-router"></a>6. vue-router</h3><ul>
<li><code>mode</code><ul>
<li><code>hash</code></li>
<li><code>history</code></li>
</ul>
</li>
<li>跳转<ul>
<li><code>this.$router.push()</code></li>
<li><code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li>
</ul>
</li>
<li>占位<ul>
<li><code>&lt;router-view&gt;&lt;/router-view&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="7-vuex"><a href="#7-vuex" class="headerlink" title="7. vuex"></a>7. vuex</h3><ul>
<li><code>state</code>: 状态中心</li>
<li><code>mutations</code>: 更改状态</li>
<li><code>actions</code>: 异步更改状态</li>
<li><code>getters</code>: 获取状态</li>
<li><code>modules</code>: 将<code>state</code>分成多个<code>modules</code>，便于管理</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>其实算法方面在前端的实际项目中涉及得并不多，但还是需要精通一些基础性的算法，一些公司还是会有这方面的需求和考核，建议大家还是需要稍微准备下，这属于加分题。</p>
<h3 id="1-五大算法"><a href="#1-五大算法" class="headerlink" title="1. 五大算法"></a>1. 五大算法</h3><ul>
<li><strong>贪心算法</strong>: 局部最优解法</li>
<li><strong>分治算法</strong>: 分成多个小模块，与原问题性质相同</li>
<li><strong>动态规划</strong>: 每个状态都是过去历史的一个总结</li>
<li><strong>回溯法</strong>: 发现原先选择不优时，退回重新选择</li>
<li><strong>分支限界法</strong></li>
</ul>
<h3 id="2-基础排序算法"><a href="#2-基础排序算法" class="headerlink" title="2. 基础排序算法"></a>2. 基础排序算法</h3><ul>
<li>冒泡排序: 两两比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> outer = len; outer &gt;= <span class="number">2</span>; outer--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> inner = <span class="number">0</span>; inner &lt;= outer - <span class="number">1</span>; inner++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[inner] &gt; arr[inner + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[inner], arr[inner + <span class="number">1</span>]] = [arr[inner + <span class="number">1</span>], arr[inner]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择排序: 遍历自身以后的元素，最小的元素跟自己调换位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入排序: 即将元素插入到已排序好的数组中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">//j = i,将arr[j]依次插入有序段中</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j - <span class="number">1</span>]] = [arr[j - <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-高级排序算法"><a href="#3-高级排序算法" class="headerlink" title="3. 高级排序算法"></a>3. 高级排序算法</h3><ul>
<li>快速排序<ul>
<li>选择基准值(base)，原数组长度减一(基准值)，使用 splice</li>
<li>循环原数组，小的放左边(left 数组)，大的放右边(right 数组);</li>
<li>concat(left, base, right)</li>
<li>递归继续排序 left 与 right</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">//递归出口</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> left = [],</span><br><span class="line">    right = [],</span><br><span class="line">    current = arr.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; current) &#123;</span><br><span class="line">      left.push(arr[i]); <span class="comment">//放在左边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]); <span class="comment">//放在右边</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat(current, quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>希尔排序：不定步数的插入排序，插入排序</p>
</li>
<li><p>口诀: 插冒归基稳定，快选堆希不稳定</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/1.png"></p>
<p>稳定性： 同大小情况下是否可能会被交换位置, 虚拟 dom 的 diff，不稳定性会导致重新渲染；</p>
<h3 id="4-递归运用-斐波那契数列-：-爬楼梯问题"><a href="#4-递归运用-斐波那契数列-：-爬楼梯问题" class="headerlink" title="4. 递归运用(斐波那契数列)： 爬楼梯问题"></a>4. 递归运用(斐波那契数列)： 爬楼梯问题</h3><p>初始在第一级，到第一级有 1 种方法(s(1) = 1)，到第二级也只有一种方法(s(2) = 1)， 第三级(s(3) = s(1) + s(2))</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cStairs(n - <span class="number">1</span>) + cStairs(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-数据树"><a href="#5-数据树" class="headerlink" title="5. 数据树"></a>5. 数据树</h3><ul>
<li>二叉树: 最多只有两个子节点<ul>
<li>完全二叉树</li>
<li>满二叉树<ul>
<li>深度为 h, 有 n 个节点，且满足 n = 2^h - 1</li>
</ul>
</li>
</ul>
</li>
<li>二叉查找树: 是一种特殊的二叉树，能有效地提高查找效率<ul>
<li>小值在左，大值在右</li>
<li>节点 n 的所有左子树值小于 n，所有右子树值大于 n</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/6.png"></p>
<ul>
<li>遍历节点<ul>
<li>前序遍历<ul>
<li><ol>
<li>根节点</li>
</ol>
</li>
<li><ol start="2">
<li>访问左子节点，回到 1</li>
</ol>
</li>
<li><ol start="3">
<li>访问右子节点，回到 1</li>
</ol>
</li>
</ul>
</li>
<li>中序遍历<ul>
<li><ol>
<li>先访问到最左的子节点</li>
</ol>
</li>
<li><ol start="2">
<li>访问该节点的父节点</li>
</ol>
</li>
<li><ol start="3">
<li>访问该父节点的右子节点， 回到 1</li>
</ol>
</li>
</ul>
</li>
<li>后序遍历<ul>
<li><ol>
<li>先访问到最左的子节点</li>
</ol>
</li>
<li><ol start="2">
<li>访问相邻的右节点</li>
</ol>
</li>
<li><ol start="3">
<li>访问父节点， 回到 1</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>插入与删除节点</li>
</ul>
<h3 id="6-天平找次品"><a href="#6-天平找次品" class="headerlink" title="6. 天平找次品"></a>6. 天平找次品</h3><p>有 n 个硬币，其中 1 个为假币，假币重量较轻，你有一把天平，请问，至少需要称多少次能保证一定找到假币?</p>
<ul>
<li>三等分算法:<ul>
<li><ol>
<li> 将硬币分成 3 组，随便取其中两组天平称量</li>
</ol>
<ul>
<li>平衡，假币在未上称的一组，取其回到 1 继续循环</li>
<li>不平衡，假币在天平上较轻的一组， 取其回到 1 继续循环</li>
</ul>
</li>
</ul>
</li>
</ul>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2018/08/22/React-%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98%E5%AE%9E%E8%B7%B5-%E4%B8%8B/">React-原理揭秘实践(下)<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/2018/11/10/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%A7%98%E7%B1%8D(%E4%B8%AD)/">中高级前端秘籍(中)<span class="note">较新</span></a><div class="line"></div><a id="more" href="/archives">检索全部文章</a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://basilbai.github.io/">@Basil</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.2" title="v1.5.2">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.2';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
