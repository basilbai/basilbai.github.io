<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>中高级前端秘籍(中) - Basil</title>

  
    <meta name="description" content="感恩!~~没想到上篇文章能这么受大家的喜欢，激动不已。🤩。但是却也是诚惶诚恐，这也意味着责任。下篇许多知识点都需要比较深入的研究和理解，博主也是水平有限，担心自己无法承担大家的期待。不过终究还是需要摆正心态，放下情绪，一字一字用心专注，不负自己，也不负社区。与各位小伙伴相互学习，共同成长，以此共勉！">
<meta property="og:type" content="article">
<meta property="og:title" content="中高级前端秘籍(中)">
<meta property="og:url" content="https://basilbai.github.io/2018/11/10/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%A7%98%E7%B1%8D(%E4%B8%AD)/index.html">
<meta property="og:site_name" content="Basil">
<meta property="og:description" content="感恩!~~没想到上篇文章能这么受大家的喜欢，激动不已。🤩。但是却也是诚惶诚恐，这也意味着责任。下篇许多知识点都需要比较深入的研究和理解，博主也是水平有限，担心自己无法承担大家的期待。不过终究还是需要摆正心态，放下情绪，一字一字用心专注，不负自己，也不负社区。与各位小伙伴相互学习，共同成长，以此共勉！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://basilbai.github.io/images/interview/7.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/8.png">
<meta property="og:image" content="https://basilbai.github.io/images/interview/9.png">
<meta property="article:published_time" content="2018-11-10T12:31:20.000Z">
<meta property="article:modified_time" content="2021-11-01T09:33:50.169Z">
<meta property="article:author" content="Basil">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://basilbai.github.io/images/interview/7.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">Basil</div><div class="sub cap">热爱技术记录分享</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/notes/">笔记</a><a class="nav-item" href="/more/">更多</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86"><span class="toc-text">进阶知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6-React"><span class="toc-text">框架: React</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1"><span class="toc-text">1. Fiber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2"><span class="toc-text">2. 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3"><span class="toc-text">3. setState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4"><span class="toc-text">4. HOC(高阶组件)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5"><span class="toc-text">5. Redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6"><span class="toc-text">6. React Hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7"><span class="toc-text">7. SSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8"><span class="toc-text">8. 函数式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Basil</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%BB%8F%E9%AA%8C%E7%A7%98%E7%B1%8D/">经验秘籍</a></div><div id="post-meta">发布于&nbsp;<time datetime="2018-11-10T12:31:20.000Z">2018-11-10</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>中高级前端秘籍(中)</span></h1>
<blockquote>
<p>感恩!~~没想到上篇文章能这么受大家的喜欢，激动不已。🤩。但是却也是诚惶诚恐，这也意味着责任。下篇许多知识点都需要比较深入的研究和理解，博主也是水平有限，担心自己无法承担大家的期待。不过终究还是需要摆正心态，放下情绪，一字一字用心专注，不负自己，也不负社区。与各位小伙伴相互学习，共同成长，以此共勉！</p>
</blockquote>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大家知道，React 现在已经在前端开发中占据了主导的地位。优异的性能，强大的生态，让其无法阻挡。据我所知，大厂也大部分以 React 作为主技术栈。React 也成为了面试中并不可少的一环。</p>
<p>中篇主要从以下几个方面对 React 展开阐述:</p>
<ul>
<li><a href="#1">Fiber</a></li>
<li><a href="#2">生命周期</a></li>
<li><a href="#3">SetState</a></li>
<li><a href="#4">HOC(高阶组件)</a></li>
<li><a href="#5">Redux</a></li>
<li><a href="#6">React Hooks</a></li>
<li><a href="#7">SSR</a></li>
<li><a href="#8">函数式编程</a></li>
</ul>
<h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><h2 id="框架-React"><a href="#框架-React" class="headerlink" title="框架: React"></a>框架: React</h2><p>React 也是现如今最流行的前端框架，也是很多大厂面试必备。React 与 Vue 虽有不同，但同样作为一款 UI 框架，虽然实现可能不一样，但在一些理念上还是有相似的，例如数据驱动、组件化、虚拟 dom 等。这里就主要列举一些 React 中独有的概念。</p>
<h3 id="1">1. Fiber</h3>

<p>React 的核心流程可以分为两个部分:</p>
<ul>
<li>reconciliation (<strong>调度算法</strong>，也可称为 render):<ul>
<li>更新 state 与 props；</li>
<li>调用生命周期钩子；</li>
<li>生成 virtual dom；</li>
<li>通过新旧 vdom 进行 diff 算法，获取 vdom change；</li>
<li>确定是否需要重新渲染</li>
</ul>
</li>
<li>commit:<ul>
<li>如需要，则操作 dom 节点更新；</li>
</ul>
</li>
</ul>
<p>要了解 Fiber，我们首先来看为什么需要它？</p>
<ul>
<li><p><strong>问题</strong>: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 <strong>同步阻塞</strong>。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 <strong>同步递归</strong> 的方式进行遍历渲染，而这个过程最大的问题就是无法 <strong>暂停和恢复</strong>。</p>
</li>
<li><p><strong>解决方案</strong>: 解决同步阻塞的方法，通常有两种: <strong>异步</strong> 与 <strong>任务分割</strong>。而 React Fiber 便是为了实现任务分割而诞生的。</p>
</li>
<li><p><strong>简述</strong>:</p>
<ul>
<li>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的 <strong>单链表树遍历算法</strong>。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。</li>
<li>这里我理解为是一种 <strong>任务分割调度算法</strong>，主要是 将原先同步更新渲染的任务分割成一个个独立的 <strong>小任务单位</strong>，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。</li>
</ul>
</li>
<li><p><strong>核心</strong>:</p>
<ul>
<li>Fiber 这里可以具象为一个 <strong>数据结构</strong>:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">instance</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    <span class="comment">// 指向第一个 child 节点</span></span><br><span class="line">    <span class="built_in">this</span>.child = child;</span><br><span class="line">    <span class="comment">// 指向父节点</span></span><br><span class="line">    <span class="built_in">this</span>.return = parent;</span><br><span class="line">    <span class="comment">// 指向第一个兄弟节点</span></span><br><span class="line">    <span class="built_in">this</span>.sibling = previous;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>链表树遍历算法</strong>: 通过 <strong>节点保存与映射</strong>，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；</p>
<ul>
<li>1、首先通过不断遍历子节点，到树末尾；</li>
<li>2、开始通过 sibling 遍历兄弟节点；</li>
<li>3、return 返回父节点，继续执行 2；</li>
<li>4、直到 root 节点后，跳出遍历；</li>
</ul>
</li>
<li><p><strong>任务分割</strong>，React 中的渲染更新可以分成两个阶段:</p>
<ul>
<li><strong>reconciliation 阶段</strong>: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。</li>
<li><strong>Commit 阶段</strong>: 将 change list 更新到 dom 上，不适合拆分，因为使用 vdom 的意义就是为了节省传说中最耗时的 dom 操作，把所有操作一次性更新，如果在这里又拆分，那不是又懵了么。🙃</li>
</ul>
</li>
<li><p><strong>分散执行</strong>: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新 API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code></p>
<ul>
<li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；</li>
<li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似于这样的方式</span></span><br><span class="line">requestIdleCallback(<span class="function">(<span class="params">deadline</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当有空闲时间时，我们执行一个组件渲染；</span></span><br><span class="line">  <span class="comment">// 把任务塞到一个个碎片时间中去；</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    (deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp;</span><br><span class="line">    nextComponent</span><br><span class="line">  ) &#123;</span><br><span class="line">    nextComponent = performWork(nextComponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优先级策略</strong>: 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips:</p>
<p>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。当遇到进程阻塞的问题时，<strong>任务分割</strong>、<strong>异步调用</strong> 和 <strong>缓存策略</strong> 是三个显著的解决思路。</p>
</blockquote>
<h3 id="2">2. 生命周期</h3>

<p>在新版本中，React 官方对生命周期有了新的 <strong>变动建议</strong>:</p>
<ul>
<li>使用<code>getDerivedStateFromProps</code> 替换<code>componentWillMount</code>；</li>
<li>使用<code>getSnapshotBeforeUpdate </code>替换<code>componentWillUpdate</code>；</li>
<li>避免使用<code>componentWillReceiveProps</code>；</li>
</ul>
<p>其实该变动的原因，正是由于上述提到的 Fiber。首先，从上面我们知道 React 可以分成 reconciliation 与 commit 两个阶段，对应的生命周期如下:</p>
<ul>
<li><p><strong>reconciliation</strong>:</p>
<ul>
<li><code>componentWillMount</code></li>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
</ul>
</li>
<li><p><strong>commit</strong>:</p>
<ul>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
</li>
</ul>
<p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 <strong>多次调用</strong> 的情况，产生一些意外错误。</p>
<p>新版的建议生命周期如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 替换 `componentWillReceiveProps` ，</span></span><br><span class="line">  <span class="comment">// 初始化和 update 时被调用</span></span><br><span class="line">  <span class="comment">// 静态函数，无法使用 this</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要更新组件</span></span><br><span class="line">  <span class="comment">// 可以用于组件性能优化</span></span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件被挂载后触发</span></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换 componentWillUpdate</span></span><br><span class="line">  <span class="comment">// 可以在更新之前获取最新 dom 数据</span></span><br><span class="line">  <span class="function"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件更新后调用</span></span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件即将销毁</span></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件已销毁</span></span><br><span class="line">  <span class="function"><span class="title">componentDidUnMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用建议</strong>:</p>
<ul>
<li>在<code>constructor</code>初始化 state；</li>
<li>在<code>componentDidMount</code>中进行事件监听，并在<code>componentWillUnmount</code>中解绑事件；</li>
<li>在<code>componentDidMount</code>中进行数据的请求，而不是在<code>componentWillMount</code>；</li>
<li>需要根据 props 更新 state 时，使用<code>getDerivedStateFromProps(nextProps, prevState)</code>；<ul>
<li>旧 props 需要自己存储，以便比较；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 当新 props 中的 data 发生变化时，同步更新到 state 上</span></span><br><span class="line">	<span class="keyword">if</span> (nextProps.data !== prevState.data) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">data</span>: nextProps.data</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> null1</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以在<code>componentDidUpdate</code>监听 props 或者 state 的变化，例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 当 id 发生变化时，重新获取数据</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.props.id !== prevProps.id) &#123;</span><br><span class="line">		<span class="built_in">this</span>.fetchData(<span class="built_in">this</span>.props.id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>componentDidUpdate</code>使用<code>setState</code>时，必须加条件，否则将进入死循环；</li>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， mounted 之前；</li>
<li><code>shouldComponentUpdate</code>: 默认每次调用<code>setState</code>，一定会最终走到 diff 阶段，但可以通过<code>shouldComponentUpdate</code>的生命钩子返回<code>false</code>来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。</li>
</ul>
</li>
</ul>
<h3 id="3">3. setState</h3>

<p>在了解<code>setState</code>之前，我们先来简单了解下 React 一个包装结构: <strong>Transaction</strong>:</p>
<ul>
<li><strong>事务</strong> (Transaction):<ul>
<li>是 React 中的一个调用结构，用于包装一个方法，结构为: <strong>initialize - perform(method) - close</strong>。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/7.png"></p>
<ul>
<li><p><code>setState</code>: React 中用于修改状态，更新视图。它具有以下特点:</p>
</li>
<li><p><strong>异步与同步</strong>: <code>setState</code>并不是单纯的异步或同步，这其实与调用时的环境相关:</p>
<ul>
<li>在 <strong>合成事件</strong> 和 <strong>生命周期钩子(除 componentDidUpdate)</strong> 中，<code>setState</code>是”异步”的；<ul>
<li><strong>原因</strong>: 因为在<code>setState</code>的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入<code>dirtyComponents</code>队列中等待执行；否则，开始执行<code>batchedUpdates</code>队列更新；<ul>
<li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而<code>componentDidUpdate</code>是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li>
<li>在合成事件中，React 是基于 <strong>事务流完成的事件委托机制</strong> 实现，也是处于事务流中；</li>
</ul>
</li>
<li><strong>问题</strong>: 无法在<code>setState</code>后马上从<code>this.state</code>上获取更新后的值。</li>
<li><strong>解决</strong>: 如果需要马上同步去获取新值，<code>setState</code>其实是可以传入第二个参数的。<code>setState(updater, callback)</code>，在回调中即可获取最新值；</li>
</ul>
</li>
<li>在 <strong>原生事件</strong> 和 <strong>setTimeout</strong> 中，<code>setState</code>是同步的，可以马上获取更新后的值；<ul>
<li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而<code>setTimeout</code>是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>批量更新</strong>: 在 <strong>合成事件</strong> 和 <strong>生命周期钩子</strong> 中，<code>setState</code>更新队列时，存储的是 <strong>合并状态</strong>(<code>Object.assign</code>)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</p>
</li>
<li><p><strong>函数式</strong>: 由于 Fiber 及 合并 的问题，官方推荐可以传入 <strong>函数</strong> 的形式。<code>setState(fn)</code>，在<code>fn</code>中返回新的<code>state</code>对象即可，例如<code>this.state((state, props) =&gt; newState)；</code></p>
<ul>
<li>使用函数式，可以用于避免<code>setState</code>的批量更新的逻辑，传入的函数将会被 <strong>顺序调用</strong>；</li>
</ul>
</li>
<li><p><strong>注意事项</strong>:</p>
<ul>
<li>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li>
<li>当组件已被销毁，如果再次调用<code>setState</code>，React 会报错警告，通常有两种解决办法:<ul>
<li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li>
<li>在组件内部维护一个状态量 (isUnmounted)，<code>componentWillUnmount</code>中标记为 true，在<code>setState</code>前进行判断；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4">4. HOC(高阶组件)</h3>

<p>HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。</p>
<ul>
<li><p><strong>简述</strong>:</p>
<ul>
<li>高阶组件不是组件，是 <strong>增强函数</strong>，可以输入一个元组件，返回出一个新的增强组件；</li>
<li>高阶组件的主要作用是 <strong>代码复用</strong>，<strong>操作</strong> 状态和参数；</li>
</ul>
</li>
<li><p><strong>用法</strong>:</p>
<ul>
<li><p><strong>属性代理 (Props Proxy)</strong>: 返回出一个组件，它基于被包裹组件进行 <strong>功能增强</strong>；</p>
<ul>
<li><strong>默认参数</strong>: 可以为组件包裹一层默认参数；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHoc</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;tayde&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>提取状态</strong>: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withOnChange</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    onChangeName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;dongdong&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="built_in">this</span>.state.name,</span><br><span class="line">        <span class="attr">onChange</span>: <span class="built_in">this</span>.onChangeName,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用姿势如下，这样就能非常快速的将一个 <code>Input</code> 组件转化成受控组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NameInput = <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withOnChange(NameInput);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>包裹组件</strong>: 可以为被包裹元素进行一层包装，</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withMask</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (</span><br><span class="line">				<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">width:</span> &#x27;<span class="attr">100</span>%&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">height:</span> &#x27;<span class="attr">100</span>%&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">backgroundColor:</span> &#x27;<span class="attr">rgba</span>(<span class="attr">0</span>, <span class="attr">0</span>, <span class="attr">0</span>, <span class="attr">.6</span>)&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">					&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">				&lt;/<span class="attr">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			)</span></span><br><span class="line"><span class="xml">		&#125;</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>反向继承</strong> (Inheritance Inversion): 返回出一个组件，<strong>继承于被包裹组件</strong>，常用于以下操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IIHoc</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Comp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>渲染劫持</strong> (Render Highjacking)</p>
<ul>
<li><strong>条件渲染</strong>: 根据条件，渲染不同的组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Comp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.props.isLoading) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以直接修改被包裹组件渲染出的 React 元素树</li>
</ul>
</li>
<li><p><strong>操作状态</strong> (Operate State): 可以直接通过 <code>this.state</code> 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li><strong>权限控制</strong>，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withAdminAuth</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> currentRole = <span class="keyword">await</span> getCurrentUserRole();</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">isAdmin</span>: currentRole === <span class="string">&quot;Admin&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state.isAdmin) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您没有权限查看该页面，请联系管理员！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>性能监控</strong>，包裹组件的生命周期，进行统一埋点:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withTiming</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Comp</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(props);</span><br><span class="line">            <span class="built_in">this</span>.start = <span class="built_in">Date</span>.now();</span><br><span class="line">            <span class="built_in">this</span>.end = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.componentDidMount &amp;&amp; <span class="built_in">super</span>.componentDidMount();</span><br><span class="line">            <span class="built_in">this</span>.end = <span class="built_in">Date</span>.now();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="subst">$&#123;<span class="built_in">this</span>.end - <span class="built_in">this</span>.start&#125;</span> ms`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码复用</strong>，可以将重复的逻辑进行抽象。</li>
</ul>
</li>
<li><p>使用注意:</p>
<ul>
<li><ol>
<li> <strong>纯函数</strong>: 增强函数应为纯函数，避免侵入修改元组件；</li>
</ol>
</li>
<li><ol start="2">
<li> <strong>避免用法污染</strong>: 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；</li>
</ol>
</li>
<li><ol start="3">
<li> <strong>命名空间</strong>: 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；</li>
</ol>
</li>
<li><ol start="4">
<li> <strong>引用传递</strong>: 如果需要传递元组件的 refs 引用，可以使用<code>React.forwardRef</code>；</li>
</ol>
</li>
<li><ol start="5">
<li> <strong>静态方法</strong>: 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:</li>
</ol>
<ul>
<li>函数导出</li>
<li>静态方法赋值</li>
</ul>
</li>
<li><ol start="6">
<li> <strong>重新渲染</strong>: 由于增强函数每次调用是返回一个新组件，因此如果在 Render 中使用增强函数，就会导致每次都重新渲染整个 HOC，而且之前的状态会丢失；</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="5">5. Redux</h3>

<p>Redux 是一个 <strong>数据管理中心</strong>，可以把它理解为一个全局的 data store 实例。它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与 React 无关，可以独立运行于任何 JavaScript 环境中，从而也为同构应用提供了更好的数据同步通道。</p>
<ul>
<li><p><strong>核心理念</strong>:</p>
<ul>
<li><strong>单一数据源</strong>: 整个应用只有唯一的状态树，也就是所有 state 最终维护在一个根级 Store 中；</li>
<li><strong>状态只读</strong>: 为了保证状态的可控性，最好的方式就是监控状态的变化。那这里就两个必要条件：<ul>
<li>Redux Store 中的数据无法被直接修改；</li>
<li>严格控制修改的执行；</li>
</ul>
</li>
<li><strong>纯函数</strong>: 规定只能通过一个纯函数 (Reducer) 来描述修改；</li>
</ul>
</li>
<li><p>大致的数据结构如下所示:</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/8.png"></p>
<ul>
<li><p><strong>理念实现</strong>:</p>
<ul>
<li><strong>Store</strong>: 全局 Store 单例， 每个 Redux 应用下只有一个 store， 它具有以下方法供使用:<ul>
<li><code>getState</code>: 获取 state；</li>
<li><code>dispatch</code>: 触发 action, 更新 state；</li>
<li><code>subscribe</code>: 订阅数据变更，注册监听器；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(Reducer, initStore);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Action</strong>: 它作为一个行为载体，用于映射相应的 Reducer，并且它可以成为数据的载体，将数据从应用传递至 store 中，是 store <strong>唯一的数据源</strong>；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个普通的 Action</span></span><br><span class="line"> <span class="keyword">const</span> action = &#123;</span><br><span class="line">	<span class="attr">type</span>: <span class="string">&#x27;ADD_LIST&#x27;</span>,</span><br><span class="line">	<span class="attr">item</span>: <span class="string">&#x27;list-item-1&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">store.dispatch(action)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常为了便于调用，会有一个 Action 创建函数 (action creater)</span></span><br><span class="line">funtion <span class="function"><span class="title">addList</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const</span> action = &#123;</span><br><span class="line">		<span class="attr">type</span>: <span class="string">&#x27;ADD_LIST&#x27;</span>,</span><br><span class="line">		item,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用就会变成:</span></span><br><span class="line">dispatch(addList(<span class="string">&#x27;list-item-1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Reducer</strong>: 用于描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个常规的 Reducer</span></span><br><span class="line"><span class="comment">// @param &#123;state&#125;: 旧数据</span></span><br><span class="line"><span class="comment">// @param &#123;action&#125;: Action 对象</span></span><br><span class="line"><span class="comment">// @returns &#123;any&#125;: 新数据</span></span><br><span class="line"><span class="keyword">const</span> initList = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListReducer</span>(<span class="params">state = initList, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD_LIST&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.concat([action.item]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      defalut: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>:</p>
<ol>
<li> 遵守数据不可变，不要去直接修改 state，而是返回出一个 <strong>新对象</strong>，可以使用 <code>assign / copy / extend / 解构</code> 等方式创建新对象；</li>
<li> 默认情况下需要 <strong>返回原数据</strong>，避免数据被清空；</li>
<li> 最好设置 <strong>初始值</strong>，便于应用的初始化及数据稳定；</li>
</ol>
</blockquote>
</li>
<li><p><strong>进阶</strong>:</p>
<ul>
<li><strong>React-Redux</strong>: 结合 React 使用；<ul>
<li><code>&lt;Provider&gt;</code>: 将 store 通过 context 传入组件中；</li>
<li><code>connect</code>: 一个高阶组件，可以方便在 React 组件中使用 Redux；<ul>
<li><ol>
<li> 将<code>store</code>通过<code>mapStateToProps</code>进行筛选后使用<code>props</code>注入组件</li>
</ol>
</li>
<li><ol start="2">
<li> 根据<code>mapDispatchToProps</code>创建方法，当组件调用时使用<code>dispatch</code>触发对应的<code>action</code></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Reducer 的拆分与重构</strong>:<ul>
<li>随着项目越大，如果将所有状态的 reducer 全部写在一个函数中，将会 <strong>难以维护</strong>；</li>
<li>可以将 reducer 进行拆分，也就是 <strong>函数分解</strong>，最终再使用<code>combineReducers()</code>进行重构合并；</li>
</ul>
</li>
<li><strong>异步 Action</strong>: 由于 Reducer 是一个严格的纯函数，因此无法在 Reducer 中进行数据的请求，需要先获取数据，再<code>dispatch(Action)</code>即可，下面是三种不同的异步实现:<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/reduxjs/redux-thunk">redex-thunk</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redux-saga/redux-saga">redux-saga</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redux-observable/redux-observable">redux-observable</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6">6. React Hooks</h3>

<p>React 中通常使用 <strong>类定义</strong> 或者 <strong>函数定义</strong> 创建组件:</p>
<p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p>
<ul>
<li><p><strong>好处</strong>:</p>
<ul>
<li>1、<strong>跨组件复用</strong>: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</li>
<li>2、<strong>类定义更为复杂</strong>:<ul>
<li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li>
<li>时刻需要关注<code>this</code>的指向问题；</li>
<li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li>
</ul>
</li>
<li>3、<strong>状态与 UI 隔离</strong>: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</li>
</ul>
</li>
<li><p><strong>注意</strong>:</p>
<ul>
<li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li>
<li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li>
<li>不能在<code>useEffect</code>中使用<code>useState</code>，React 会报错提示；</li>
<li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li>
</ul>
</li>
<li><p><strong>重要钩子*</strong>:</p>
<ul>
<li><strong>状态钩子</strong> (<code>useState</code>): 用于定义组件的 State，其到类定义中<code>this.state</code>的功能；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useState 只接受一个参数: 初始状态</span></span><br><span class="line"><span class="comment">// 返回的是组件名和更改该组件对应的函数</span></span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 修改状态</span></span><br><span class="line">setFlag(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码映射到类定义中:</span></span><br><span class="line"><span class="built_in">this</span>.state = &#123;</span><br><span class="line">  <span class="attr">flag</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> flag = <span class="built_in">this</span>.state.flag;</span><br><span class="line"><span class="keyword">const</span> setFlag = <span class="function">(<span class="params">bool</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">flag</span>: bool,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生命周期钩子</strong> (<code>useEffect</code>):</li>
</ul>
<p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (<code>useEffect</code>)，这里可以看做<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的结合。</p>
<ul>
<li><code>useEffect(callback, [source])</code>接受两个参数<ul>
<li><code>callback</code>: 钩子回调函数；</li>
<li><code>source</code>: 设置触发条件，仅当 source 发生改变时才会触发；</li>
<li><code>useEffect</code>钩子在没有传入<code>[source]</code>参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件挂载后执行事件绑定</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  addEventListener();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件 update 时会执行事件解绑</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">    removeEventListener();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [source]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):</span></span><br><span class="line"><span class="comment">// --- DidMount ---</span></span><br><span class="line"><span class="comment">// &#x27;on&#x27;</span></span><br><span class="line"><span class="comment">// --- DidUpdate ---</span></span><br><span class="line"><span class="comment">// &#x27;off&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;on&#x27;</span></span><br><span class="line"><span class="comment">// --- DidUpdate ---</span></span><br><span class="line"><span class="comment">// &#x27;off&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;on&#x27;</span></span><br><span class="line"><span class="comment">// --- WillUnmount ---</span></span><br><span class="line"><span class="comment">// &#x27;off&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过第二个参数，我们便可模拟出几个常用的生命周期:</p>
<ul>
<li><code>componentDidMount</code>: 传入<code>[]</code>时，就只会在初始化时调用一次；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useMount = <span class="function">(<span class="params">fn</span>) =&gt;</span> useEffect(fn, []);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>componentWillUnmount</code>: 传入<code>[]</code>，回调中的返回的函数也只会被最终执行一次；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUnmount = <span class="function">(<span class="params">fn</span>) =&gt;</span> useEffect(<span class="function">() =&gt;</span> fn, []);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mounted </code>: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useMounted = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [mounted, setMounted] = useState(<span class="literal">false</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    !mounted &amp;&amp; setMounted(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> setMounted(<span class="literal">false</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> mounted;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>componentDidUpdate</code>: <code>useEffect</code>每次均会执行，其实就是排除了 DidMount 后即可；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mounted = useMounted();</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  mounted &amp;&amp; fn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>其它内置钩子</strong>:</p>
<ul>
<li><p><code>useContext</code>: 获取 context 对象</p>
</li>
<li><p><code>useReducer</code>: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p>
<ul>
<li>并不是持久化存储，会随着组件被销毁而销毁；</li>
<li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li>
<li>配合<code>useContext</code>的全局性，可以完成一个轻量级的 Redux；(<a target="_blank" rel="noopener" href="https://github.com/ctrlplusb/easy-peasy">easy-peasy</a>)</li>
</ul>
</li>
<li><p><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</p>
</li>
<li><p><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</p>
</li>
<li><p><code>useRef</code>: 获取组件的真实节点；</p>
</li>
<li><p><code>useLayoutEffect</code>:</p>
<ul>
<li>DOM 更新同步钩子。用法与<code>useEffect</code>类似，只是区别于执行时间点的不同。</li>
<li><code>useEffect</code>属于异步执行，并不会等待 DOM 真正渲染后执行，而<code>useLayoutEffect</code>则会真正渲染后才触发；</li>
<li>可以获取更新后的 state；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自定义钩子</strong>(<code>useXxxxx</code>): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的<code>useMounted</code>。又例如，我们需要每个页面自定义标题:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = title;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> title = <span class="string">&quot;我是首页&quot;</span>;</span><br><span class="line">  useTitle(title);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7">7. SSR</h3>

<p>SSR，俗称 <strong>服务端渲染</strong> (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。</p>
<ul>
<li><p><strong>前后端分离</strong>: 前端与服务端隔离，前端动态获取数据，渲染页面。</p>
</li>
<li><p><strong>痛点</strong>:</p>
<ul>
<li><p><strong>首屏渲染性能瓶颈</strong>:</p>
<ul>
<li>空白延迟: HTML 下载时间 + JS 下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。</li>
</ul>
</li>
<li><p><strong>SEO 问题</strong>: 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。</p>
<ul>
<li>虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独立的开发模式，又要由服务端渲染，因此我们使用 React SSR。</p>
<ul>
<li><strong>原理</strong>:<ul>
<li>Node 服务: 让前后端运行同一套代码成为可能。</li>
<li>Virtual Dom: 让前端代码脱离浏览器运行。</li>
</ul>
</li>
<li><strong>条件</strong>: Node 中间层、 React / Vue 等框架。 结构大概如下:</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/interview/9.png"></p>
<ul>
<li><p><strong>开发流程</strong>: (此处以 React + Router + Redux + Koa 为例)</p>
<ul>
<li>1、在同个项目中，<strong>搭建</strong> 前后端部分，常规结构:<ul>
<li>build</li>
<li>public</li>
<li>src<ul>
<li>client</li>
<li>server</li>
</ul>
</li>
</ul>
</li>
<li>2、server 中使用 Koa <strong>路由监听</strong> 页面访问:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Router <span class="keyword">from</span> <span class="string">&quot;koa-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="comment">// 如果中间也提供 Api 层</span></span><br><span class="line">router.use(<span class="string">&quot;/api/home&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 返回数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&quot;*&quot;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 返回 HTML</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>3、通过访问 url <strong>匹配</strong> 前端页面路由:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端页面路由</span></span><br><span class="line"><span class="keyword">import</span> &#123; pages &#125; <span class="keyword">from</span> <span class="string">&quot;../../client/app&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; matchPath &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 react-router 库提供的一个匹配方法</span></span><br><span class="line"><span class="keyword">const</span> matchPage = matchPath(ctx.req.url, page);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>4、通过页面路由的配置进行 <strong>数据获取</strong>。通常可以在页面路由中增加 SSR 相关的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> ssrConfig = &#123;</span><br><span class="line">		  <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="function"><span class="title">fetch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        	  <span class="comment">// 请求获取数据</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取数据通常有两种情况:</p>
<ul>
<li>中间层也使用 <strong>http</strong> 获取数据，则此时 fetch 方法可前后端共享；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> matchPage.ssrConfig.fetch();</span><br></pre></td></tr></table></figure>

<ul>
<li>中间层并不使用 http，是通过一些 <strong>内部调用</strong>，例如 Rpc 或 直接读数据库 等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面路由</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> ssrConfig = &#123;</span><br><span class="line">        <span class="attr">fetch</span>: &#123;</span><br><span class="line">        	 <span class="attr">url</span>: <span class="string">&#x27;/api/home&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则匹配出对应的数据获取方法</span></span><br><span class="line"><span class="comment">// 这里的规则可以自由，只要能匹配出正确的方法即可</span></span><br><span class="line"><span class="keyword">const</span> controller = matchController(ssrConfig.fetch.url)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> controller(ctx)</span><br></pre></td></tr></table></figure></li>
<li><p>5、创建 Redux store，并将数据<code>dispatch</code>到里面:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="comment">// 获取 Clinet层 reducer</span></span><br><span class="line"><span class="comment">// 必须复用前端层的逻辑，才能保证一致性；</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducers &#125; <span class="keyword">from</span> <span class="string">&quot;../../client/store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置好的 Action</span></span><br><span class="line"><span class="keyword">const</span> action = ssrConfig.action;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line">store.dispatch(createAction(action)(data));</span><br></pre></td></tr></table></figure>

<ul>
<li>6、注入 Store， 调用<code>renderToString</code>将 React Virtual Dom 渲染成 <strong>字符串</strong>:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&quot;react-dom/server&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Clinet 层根组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; App &#125; <span class="keyword">from</span> <span class="string">&quot;../../client/app&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppString = ReactDOMServer.renderToString(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">StaticRouter</span> <span class="attr">location</span>=<span class="string">&#123;ctx.req.url&#125;</span> <span class="attr">context</span>=<span class="string">&#123;&#123;&#125;&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">StaticRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>7、将 AppString 包装成完整的 html 文件格式；</p>
</li>
<li><p>8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的页面，没有样式没有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成的<code>asset-manifest.json</code>文件来获取相应的文件路径，并同样注入到 Html 中引用。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">	&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">	&lt;html lang=&quot;zh&quot;&gt;</span></span><br><span class="line"><span class="string">		&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">		&lt;link href=&quot;<span class="subst">$&#123;cssPath&#125;</span>&quot; rel=&quot;stylesheet&quot; /&gt;</span></span><br><span class="line"><span class="string">		&lt;body&gt;</span></span><br><span class="line"><span class="string">			&lt;div id=&quot;App&quot;&gt;<span class="subst">$&#123;AppString&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">			&lt;script src=&quot;<span class="subst">$&#123;scriptPath&#125;</span>&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">		&lt;/body&gt;</span></span><br><span class="line"><span class="string">	&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>9、进行 <strong>数据脱水</strong>: 为了把服务端获取的数据同步到前端。主要是将数据序列化后，插入到 html 中，返回给前端。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> serialize <span class="keyword">from</span> <span class="string">&quot;serialize-javascript&quot;</span>;</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">const</span> initState = store.getState();</span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">	&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">	&lt;html lang=&quot;zh&quot;&gt;</span></span><br><span class="line"><span class="string">		&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">		&lt;body&gt;</span></span><br><span class="line"><span class="string">			&lt;div id=&quot;App&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">			&lt;script type=&quot;application/json&quot; id=&quot;SSR_HYDRATED_DATA&quot;&gt;<span class="subst">$&#123;serialize(</span></span></span><br><span class="line"><span class="subst"><span class="string">        initState</span></span></span><br><span class="line"><span class="subst"><span class="string">      )&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">		&lt;/body&gt;</span></span><br><span class="line"><span class="string">	&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">ctx.status = <span class="number">200</span>;</span><br><span class="line">ctx.body = html;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong>:</p>
<p>这里比较特别的有两点:</p>
<ol>
<li><p> 使用了<code>serialize-javascript</code>序列化 store， 替代了<code>JSON.stringify</code>，保证数据的安全性，避免代码注入和 XSS 攻击；</p>
</li>
<li><p> 使用 json 进行传输，可以获得更快的加载速度；</p>
</li>
</ol>
</blockquote>
<ul>
<li>10、Client 层 <strong>数据吸水</strong>: 初始化 store 时，以脱水后的数据为初始化数据，同步创建 store。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hydratedEl = <span class="built_in">document</span>.getElementById(<span class="string">&quot;SSR_HYDRATED_DATA&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> hydrateData = <span class="built_in">JSON</span>.parse(hydratedEl.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始 state 创建 Redux store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, hydrateData);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8">8. 函数式编程</h3>

<p>函数式编程是一种 <strong>编程范式</strong>，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 <strong>更简洁、可预测、高复用、易测试</strong>。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。</p>
<ul>
<li><p><strong>常见的编程范式</strong>:</p>
<ul>
<li>命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；</li>
<li>事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；</li>
<li>面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；</li>
<li>函数式编程<ul>
<li>换成一种更高端的说法，面向数学编程。怕不怕~🥴</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>函数式编程的理念</strong>:</p>
<ul>
<li><p><strong>纯函数</strong>(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；</p>
<ul>
<li><p><strong>优势</strong>:</p>
<ul>
<li>完全独立，与外部解耦；</li>
<li>高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；</li>
<li>可测试性极强；</li>
</ul>
</li>
<li><p><strong>条件</strong>:</p>
<ul>
<li>不修改参数；</li>
<li>不依赖、不修改任何函数外部的数据；</li>
<li>完全可控，参数一样，返回值一定一样: 例如函数不能包含<code>new Date()</code>或者<code>Math.randon()</code>等这种不可控因素；</li>
<li>引用透明；</li>
</ul>
</li>
<li><p>我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如<code>split / join / map</code>；</p>
</li>
</ul>
</li>
<li><p><strong>函数复合</strong>: 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最后的目标；</p>
<ul>
<li><p><strong>扁平化嵌套</strong>: 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在 JS 中，函数也可以当做参数:</p>
<ul>
<li><code>f(g(k(x)))</code>: 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；</li>
<li>理想的做法: <code>xxx(f, g, k)(x)</code></li>
</ul>
</li>
<li><p><strong>结果传递</strong>: 如果想实现上面的方式，那也就是<code>xxx</code>函数要实现的便是: 执行结果在各个函数之间的执行传递；</p>
<ul>
<li>这时我们就能想到一个原生提供的数组方法: <code>reduce</code>，它可以按数组的顺序依次执行，传递执行结果；</li>
<li>所以我们就能够实现一个方法<code>pipe</code>，用于函数组合:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...fs: 将函数组合成数组；</span></span><br><span class="line"><span class="comment">// Array.prototype.reduce 进行组合；</span></span><br><span class="line"><span class="comment">// p: 初始参数；</span></span><br><span class="line"><span class="keyword">const</span> pipe =</span><br><span class="line">  <span class="function">(<span class="params">...fs</span>) =&gt;</span></span><br><span class="line">  <span class="function">(<span class="params">p</span>) =&gt;</span></span><br><span class="line">    fs.reduce(<span class="function">(<span class="params">v, f</span>) =&gt;</span> f(v), p);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用</strong>: 实现一个 驼峰命名 转 中划线命名 的功能:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;Guo DongDong&#x27; --&gt; &#x27;guo-dongdong&#x27;</span></span><br><span class="line"><span class="comment">// 函数组合式写法</span></span><br><span class="line"><span class="keyword">const</span> toLowerCase = <span class="function">(<span class="params">str</span>) =&gt;</span> str.toLowerCase();</span><br><span class="line"><span class="keyword">const</span> join = curry(<span class="function">(<span class="params">str, arr</span>) =&gt;</span> arr.join(str));</span><br><span class="line"><span class="keyword">const</span> split = curry(<span class="function">(<span class="params">splitOn, str</span>) =&gt;</span> str.split(splitOn));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toSlug = pipe(toLowerCase, split(<span class="string">&quot; &quot;</span>), join(<span class="string">&quot;_&quot;</span>), <span class="built_in">encodeURIComponent</span>);</span><br><span class="line"><span class="built_in">console</span>.log(toSlug(<span class="string">&quot;Guo DongDong&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>好处</strong>:</p>
<ul>
<li>隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；</li>
<li>只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；</li>
<li>可复用性强，任何一个函数单元都可被任意复用和组合；</li>
<li>可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = curry(<span class="function">(<span class="params">label, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;label&#125;</span>: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toSlug = pipe(</span><br><span class="line">  toLowerCase,</span><br><span class="line">  log(<span class="string">&quot;toLowerCase output&quot;</span>),</span><br><span class="line">  split(<span class="string">&quot; &quot;</span>),</span><br><span class="line">  log(<span class="string">&quot;split output&quot;</span>),</span><br><span class="line">  join(<span class="string">&quot;_&quot;</span>),</span><br><span class="line">  log(<span class="string">&quot;join output&quot;</span>),</span><br><span class="line">  <span class="built_in">encodeURIComponent</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Tips:</p>
<p>一些工具纯函数可直接引用<code>lodash/fp</code>，例如<code>curry/map/split</code>等，并不需要像我们上面这样自己实现；</p>
</blockquote>
</li>
<li><p><strong>数据不可变性</strong>(immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:</p>
<ul>
<li><strong>倡导</strong>: 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新的对象，而不是直接在原对象上修改；</li>
<li><strong>目的</strong>: 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异常，能有效提高可控性与稳定性；</li>
<li>并不等同于<code>const</code>。使用<code>const</code>创建一个对象后，它的属性仍然可以被修改；</li>
<li>更类似于<code>Object.freeze</code>: 冻结对象，但<code>freeze</code>仍无法保证深层的属性不被串改；</li>
<li><code>immutable.js</code>: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被广泛应用，大大提升了性能与稳定性；<ul>
<li><code>trie</code>数据结构:<ul>
<li>一种数据结构，能有效地深度冻结对象，保证其不可变；</li>
<li><strong>结构共享</strong>: 可以共用不可变对象的内存引用地址，减少内存占用，提高数据操作性能；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>避免不同函数之间的 <strong>状态共享</strong>，数据的传递使用复制或全新对象，遵守数据不可变原则；</p>
</li>
<li><p>避免从函数内部 <strong>改变外部状态</strong>，例如改变了全局作用域或父级作用域上的变量值，可能会导致其它单位错误；</p>
</li>
<li><p>避免在单元函数内部执行一些 <strong>副作用</strong>，应该将这些操作抽离成更独立的工具单元；</p>
<ul>
<li>日志输出</li>
<li>读写文件</li>
<li>网络请求</li>
<li>调用外部进程</li>
<li>调用有副作用的函数</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>高阶函数</strong>: 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:</p>
<ul>
<li>将逻辑行为进行 <strong>隔离抽象</strong>，便于快速复用，如处理数据，兼容性等；</li>
<li><strong>函数组合</strong>，将一系列单元函数列表组合成功能更强大的函数；</li>
<li><strong>函数增强</strong>，快速地拓展函数功能，</li>
</ul>
</li>
<li><p><strong>函数式编程的好处</strong>:</p>
<ul>
<li>函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；</li>
<li>不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；</li>
<li>追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；</li>
<li>更易于做单元测试。</li>
</ul>
</li>
<li><p><strong>总结</strong>:</p>
<ul>
<li>函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；</li>
<li>它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips:</p>
<p>其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些个人理解而已。博主也是初级小菜鸟，停留在表面而已，只求对大家能有所帮助，轻喷 🤣；</p>
<p>我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 <strong>优劣势</strong>。</p>
<p>理解和学习它们的理念与优势，合理地 <strong>设计融合</strong>，将优秀的软件编程思想用于提升我们应用；</p>
<p>所有设计思想，最终的目标一定是使我们的应用更加 <strong>解耦颗粒化、易拓展、易测试、高复用，开发更为高效和安全</strong>；</p>
<p>有一些库能让大家很快地接触和运用函数思想: <code>Underscore.js</code> / <code>Lodash/fp</code> / <code>Rxjs</code> 等。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到此，想必大家会发现已经开始深入一些理论和原理层面了，并不像上篇那么的浅显易懂了。但这也是个必经之路，不可能永远停留在 <strong>5 分钟掌握的技术</strong> 上。不再停留在语言的表面，而是理解更深入的原理，模式，架构，因果，你就会突然发现你成为高级软件工程师了。😁。</p>
<p>希望各位小伙伴能沉下心来，一些理论、概念虽然枯燥，但反复琢磨后再自己实践尝试下，就能有自己的理解。</p>
<p>当你开始面试高级工程师时，面试官便不再重点关注你会不会写<code>stopPropagation</code>或者会不会水平居中了，而是更在乎你自己的思考和研究能力了。表现出自己深入理解研究的成果，定会让面试官刮目相看。</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2018/10/28/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%A7%98%E7%B1%8D(%E4%B8%8A)/">中高级前端秘籍(上)<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/2018/12/18/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%A7%98%E7%B1%8D(%E4%B8%8B)/">中高级前端秘籍(下)<span class="note">较新</span></a><div class="line"></div><a id="more" href="/archives">检索全部文章</a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://basilbai.github.io/">@Basil</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.2" title="v1.5.2">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.2';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
